

./src/core/application.c:

#include "application.h"
#include "../renderer/texture.h"
#include <stdio.h>
#include <GLFW/glfw3.h>
#include <time.h>
#include <stdbool.h>

#ifdef _WIN32
#include <windows.h>
#else
#include <unistd.h>
#endif

// Инициализация приложения
bool application_init(Application* app) {
    // Инициализируем окно
    if (!window_init(&app->window, 800, 600, "Rubik's Cube")) {
        fprintf(stderr, "Failed to initialize window\n");
        return false;
    }
    
    // Устанавливаем указатель на приложение для окна
    app->window.app = (struct Application*)app;
    
    // Инициализируем текстуры
    if (!texture_init_system()) {
        fprintf(stderr, "Failed to initialize texture system\n");
        return false;
    }
    
    printf("Texture system initialized\n");
    
    // Инициализируем сцену с кубом Рубика 
    if (!scene_init_rubiks(&app->scene)) {
        fprintf(stderr, "Failed to initialize Rubik's cube scene\n");
        return false;
    }
    
    app->running = true;
    app->lastFrame = 0.0f;
    app->deltaTime = 0.0f;
    app->targetFPS = 60.0f;
    app->frameTimeTarget = 1.0f / app->targetFPS;
    app->needsRedraw = true;
    
    return true;
}

// Кроссплатформенная функция сна
void sleep_ms(int milliseconds) {
#ifdef _WIN32
    Sleep(milliseconds);
#else
    usleep(milliseconds * 1000);
#endif
}

// Цикл приложения
void application_run(Application* app) {
    // Главный цикл приложения
    while (app->running && !window_should_close(&app->window)) {
        // Время с прошлого кадра
        float currentFrame = (float)glfwGetTime();
        app->deltaTime = currentFrame - app->lastFrame;
        
        // Опрашиваем события
        window_poll_events();
        
        // Обновляем сцену только если прошло достаточно времени для достижения целевого FPS
        if (app->deltaTime >= app->frameTimeTarget) {
            scene_update(&app->scene, &app->window, app->deltaTime);
            app->lastFrame = currentFrame;
            app->needsRedraw = true;
        }
        
        // Рисуем только когда необходимо
        if (app->needsRedraw) {
            scene_render(&app->scene, &app->window);
            window_swap_buffers(&app->window);
            app->needsRedraw = false;
        }
        
        // Вычисляем, сколько времени мы должны спать, чтобы поддерживать целевой FPS
        float frameTime = (float)glfwGetTime() - currentFrame;
        if (frameTime < app->frameTimeTarget) {
            int sleepTime = (int)((app->frameTimeTarget - frameTime) * 1000);
            if (sleepTime > 0) {
                sleep_ms(sleepTime);
            }
        }
    }
}

// Очистка ресурсов
void application_cleanup(Application* app) {
    scene_destroy(&app->scene);
    texture_cleanup_system();
    window_destroy(&app->window);
} 

./src/core/application.h:

#ifndef APPLICATION_H
#define APPLICATION_H

#include "window.h"
#include "../scene/scene.h"
#include <stdbool.h>

typedef struct Application {
    Window window;
    Scene scene;
    bool running;
    float lastFrame;
    float deltaTime;
    float targetFPS;
    float frameTimeTarget;
    bool needsRedraw;
} Application;

bool application_init    (Application* app);
void application_run     (Application* app);
void application_cleanup (Application* app);

#endif /* APPLICATION_H */ 

./src/core/camera.c:

#define _USE_MATH_DEFINES

#include "camera.h"
#include <math.h>
#include <stdio.h>

void camera_init(Camera* camera) {
    // Положение объекта вращения и направления вверх
    camera->up = (Vec3){0.0f, 1.0f, 0.0f};
    
    // Начальное положение
    camera->radius = 5.0f;
    camera->theta = 45.0f;   // 45 degrees around Y axis
    camera->phi = 45.0f;     // 45 degrees from Y axis
    
    // Параметры проекции
    camera->fov = 45.0f;
    camera->nearPlane = 0.1f;
    camera->farPlane = 100.0f;
    
    // Параметры интеракции с камерой
    camera->isDragging = false;
    camera->lastMouseX = 0.0;
    camera->lastMouseY = 0.0;
    
    camera->sensitivity = 0.3f;
    camera->zoomSpeed = 0.5f;
    camera->minRadius = 2.0f;
    camera->maxRadius = 15.0f;
    camera->minPhi = 5.0f;
    camera->maxPhi = 175.0f;
    
    camera_update(camera);
}

// Обработка движения мыши
void camera_process_mouse_movement(Camera* camera, double xpos, double ypos) {
    if (!camera->isDragging) {
        return;
    }
    
    // dx, dy
    double xoffset = xpos - camera->lastMouseX;
    double yoffset = camera->lastMouseY - ypos;
    
    xoffset *= camera->sensitivity;
    yoffset *= camera->sensitivity;
    
    // Обновление углов полжения камеры на dx, dy
    camera->theta -= xoffset; 
    camera->phi -= yoffset; 
    
    // Ограничение вращения phi для того чтобы избежать gimbal lock
    if (camera->phi < camera->minPhi) camera->phi = camera->minPhi;
    if (camera->phi > camera->maxPhi) camera->phi = camera->maxPhi;
    
    // Нормализация theta до [0.0, 360.0]
    while (camera->theta > 360.0f) camera->theta -= 360.0f;
    while (camera->theta < 0.0f) camera->theta += 360.0f;
    
    camera->lastMouseX = xpos;
    camera->lastMouseY = ypos;
    
    // Обновить позицию камеры на основании новых углов
    camera_update(camera);
}

void camera_start_drag(Camera* camera, double xpos, double ypos) {
    camera->isDragging = true;
    camera->lastMouseX = xpos;
    camera->lastMouseY = ypos;
}

void camera_end_drag(Camera* camera) {
    camera->isDragging = false;
}

// Обработка скролла
void camera_process_scroll(Camera* camera, double yoffset) {
    // Приближение 
    camera->radius -= yoffset * camera->zoomSpeed;
    
    // Ограничение зума
    if (camera->radius < camera->minRadius) camera->radius = camera->minRadius;
    if (camera->radius > camera->maxRadius) camera->radius = camera->maxRadius;
    
    // Обновление позиции камеры на новом радиусе
    camera_update(camera);
}

void camera_update(Camera* camera) {
    // Преобразование из сферических в декартовы
    float thetaRad = camera->theta * M_PI / 180.0f;
    float phiRad = camera->phi * M_PI / 180.0f;
    
    camera->position.x = camera->radius * sinf(phiRad) * cosf(thetaRad);
    camera->position.y = camera->radius * cosf(phiRad);
    camera->position.z = camera->radius * sinf(phiRad) * sinf(thetaRad);
}


// Проекции для шейдеров
Mat4 camera_get_view_matrix(Camera* camera) {
    return mat4_look_at(camera->position, (Vec3){0.0f, 0.0f, 0.0f}, camera->up);
}

Mat4 camera_get_projection_matrix(Camera* camera, float aspectRatio) {
    // FOV deg to rad
    float fovRadians = camera->fov * M_PI / 180.0f;
    
    return mat4_perspective(fovRadians, aspectRatio, camera->nearPlane, camera->farPlane);
}

// Перемещение камеры до позиции за n секунд
void camera_move_to(Camera* camera, float targetTheta, float targetPhi, float duration) {
    camera->moveStartTheta = camera->theta;
    camera->moveEndTheta = targetTheta;
    camera->moveStartPhi = camera->phi;
    camera->moveEndPhi = targetPhi;
    camera->moveTimer = 0.0f;
    camera->moveDuration = duration > 0.0f ? duration : 0.01f;
    camera->isMoving = true;
}

// Вызывается каждый фрейм чтобы апдейтить позицию камеры
void camera_update_movement(Camera* camera, float deltaTime) {
    if (!camera->isMoving) return;
    camera->moveTimer += deltaTime;
    float t = camera->moveTimer / camera->moveDuration;
    if (t >= 1.0f) {
        camera->theta = camera->moveEndTheta;
        camera->phi = camera->moveEndPhi;
        camera->isMoving = false;
    } else {
        camera->theta = camera->moveStartTheta + t * (camera->moveEndTheta - camera->moveStartTheta);
        camera->phi = camera->moveStartPhi + t * (camera->moveEndPhi - camera->moveStartPhi);
    }
    camera_update(camera);
}

bool camera_is_moving(Camera* camera) {
    return camera->isMoving;
} 

./src/core/camera.h:

#ifndef CAMERA_H
#define CAMERA_H

#include <stdbool.h>
#include "../math/vec3.h"
#include "../math/mat4.h"

typedef struct {
    // Координаты камеры и вектора вверх
    Vec3 position;
    Vec3 up;
    
    // Параметры орбиты
    float radius;     // Растояние до цели
    float theta;      // Горизонтальный угол
    float phi;        // Вертикальный угол
    
    // Параметры проекции
    float fov;        // FOV в градусах
    float nearPlane;  // Растояние после которого объекты не отображатся
    float farPlane;   // Растояние после которого объекты не отображатся
    
    // Состояния интеракции с камерой
    bool isDragging;
    double lastMouseX;
    double lastMouseY;
    
    // Настройки камеры
    float sensitivity;    // Чувсвтительность мыши
    float zoomSpeed;      // Скорость зума
    float minRadius;      // Минимальный зум
    float maxRadius;      // Максимальный зум
    float minPhi;         // Минимальный вертикальный угол
    float maxPhi;         // Максимальный вертикальный угол

    // Для движения по таймеру
    float moveStartTheta, moveEndTheta;
    float moveStartPhi, moveEndPhi;
    float moveTimer;      // Прошедшее время
    float moveDuration;   // Общее время
    bool isMoving;        
} Camera;

void camera_init (Camera* camera);


void camera_process_mouse_movement (Camera* camera, double xpos, double ypos);
void camera_start_drag             (Camera* camera, double xpos, double ypos);
void camera_end_drag               (Camera* camera);
void camera_process_scroll         (Camera* camera, double yoffset);


void camera_update (Camera* camera);


Mat4 camera_get_view_matrix       (Camera* camera);
Mat4 camera_get_projection_matrix (Camera* camera, float aspectRatio);


void camera_move_to         (Camera* camera, float targetTheta, float targetPhi, float duration);
void camera_update_movement (Camera* camera, float deltaTime);
bool camera_is_moving       (Camera* camera);

#endif /* CAMERA_H */ 

./src/core/window.c:

#define _USE_MATH_DEFINES

#include "window.h"
#include "application.h"
#include "../scene/scene.h"
#include "../solver/cube_solver.h"
#include <stdio.h>
#include <math.h>
#include <stdlib.h>
#include <time.h>

static void handle_move_sequence(struct Application* app, char** moveSequence, bool browseMode, float speed);
static char** generate_random_move_sequence(int length);
static char* generate_random_move(char excludeFace);
static void framebuffer_size_callback(GLFWwindow* handle, int width, int height);

// Функция для изменения размеров окна
static void framebuffer_size_callback(GLFWwindow* handle, int width, int height) {
    glViewport(0, 0, width, height);
    Window* window = (Window*)glfwGetWindowUserPointer(handle);
    window->width = width;
    window->height = height;
}

static char** generate_random_move_sequence(int length) {
    char** moveSequence = malloc((length + 1) * sizeof(char*));
    char lastFace = '\0';
    
    for (int i = 0; i < length; i++) {
        moveSequence[i] = generate_random_move(lastFace);
        lastFace = moveSequence[i][0];
    }
    moveSequence[length] = NULL;
    return moveSequence;
}

static char* generate_random_move(char excludeFace) {
    char* move_names[] = {
        "U", "U'", "U2",
        "D", "D'", "D2",
        "F", "F'", "F2",
        "B", "B'", "B2",
        "L", "L'", "L2",
        "R", "R'", "R2"
    };
    
    char* available_moves[18];
    int available_count = 0;
    
    for (int i = 0; i < 18; i++) {
        if (move_names[i][0] != excludeFace) {
            available_moves[available_count++] = move_names[i];
        }
    }
    
    int random_move = rand() % available_count;
    return available_moves[random_move];
}

// Функция для обработки последовательности ходов
static void handle_move_sequence(struct Application* app, char** moveSequence, bool browseMode, float speed) {
    // Если загружена в режиме по ходам
    if (browseMode) {
        // Удалить существующую очередь ходов и инициализировать новую
        scene_destroy_move_queue(&app->scene);
        scene_init_move_queue(&app->scene);
        
        // Добавить ходы в очередь
        int i = 0;
        while (moveSequence[i] != NULL) {
            scene_add_move_to_queue(&app->scene, moveSequence[i]);
            i++;
        }
        
        scene_enter_browse_mode(&app->scene);
    } else {
        // Выполнить последовательность напрямую с указанной скоростью
        scene_set_speed_multiplier(&app->scene, speed);
        apply_move_sequence(&app->scene, moveSequence);
    }
}

// Функция для обработки нажатий клавиш
static void key_callback(GLFWwindow* handle, int key, int scancode, int action, int mods) {
    if (action != GLFW_PRESS) return;
    Window* window = (Window*)glfwGetWindowUserPointer(handle);
    
    // Получить ссылку на камеру
    Camera* camera = &window->camera;
    
    struct Application* app = window->app;
    if (app && !scene_is_rotating(&app->scene)) {
        // Обрабока нажатий в специальных режимах
        if (scene_is_in_browse_mode(&app->scene)) {
            // Навигация в режиме просмотра
            if (key == GLFW_KEY_RIGHT) {
                scene_browse_next(&app->scene);
            } 
            else if (key == GLFW_KEY_LEFT) {
                scene_browse_previous(&app->scene);
            } 
            else if (key == GLFW_KEY_C) {
                scene_exit_browse_mode(&app->scene);
            }
            return; // Не обрабатывать другие клавиши в режиме просмотра
        } else if (scene_is_in_color_mode(&app->scene)) {
            // Навигация в режиме цвета
            if (key == GLFW_KEY_RIGHT) {
                scene_next_color_face(&app->scene, window);
            } 
            else if (key == GLFW_KEY_LEFT) {
                scene_previous_color_face(&app->scene, window);
            } 
            // Установить цвет для текущей ячейки
            else if (key == GLFW_KEY_1) {
                scene_set_color_for_current_cell(&app->scene, window, 'W');
            }
            else if (key == GLFW_KEY_2) {
                scene_set_color_for_current_cell(&app->scene, window, 'R');
            }
            else if (key == GLFW_KEY_3) {
                scene_set_color_for_current_cell(&app->scene, window, 'B');
            }
            else if (key == GLFW_KEY_4) {
                scene_set_color_for_current_cell(&app->scene, window, 'O');
            }
            else if (key == GLFW_KEY_5) {
                scene_set_color_for_current_cell(&app->scene, window, 'G');
            }
            else if (key == GLFW_KEY_6) {
                scene_set_color_for_current_cell(&app->scene, window, 'Y');
            }
            // Выйти из режима раскраски можно только если куб валидный (решается)
            else if (key == GLFW_KEY_C) {
                char* cubeString = scene_get_cube_state_as_string(app->scene.cubeColors);
                
                bool incomplete = false;

                for (int i = 0; cubeString[i] != '\0'; i++) {
                    char c = cubeString[i];
                    if (c == '?'){
                        incomplete = true;
                        break;
                    }
                }

                if (incomplete) {
                    printf("Coloring not complete\n");
                    
                    const char* solidColors = "WWWWWWWWWRRRRRRRRRBBBBBBBBBOOOOOOOOOGGGGGGGGGYYYYYYYYY";
                    scene_set_cube_state_from_string(&app->scene, solidColors);
                    scene_exit_color_mode(&app->scene, window);
                } else {
                    bool isSolved = false;
                    char** moveSequence = cube_solver_solve(&app->scene, &isSolved);
                    if (isSolved) {
                        scene_exit_color_mode(&app->scene, window);
                    }
                    else {
                        printf("Not valid cube state\n");
                    }
                }
            }
            return; // Не обрабатывать другие клавиши в режиме цвета
        }
        
        // Обрабока нажатий в режиме вращения
        // Если shift зажат, то вращение против часовой стрелки, иначе по часовой стрелке
        int direction = (mods & GLFW_MOD_SHIFT) ? -1 : 1; 
        
        // Верхняя грань (Up - U)
        if (key == GLFW_KEY_U) {
            scene_start_rotation(&app->scene, FACE_IDX_TOP, direction, 1);
            printf("Rotating top face %s\n", 
                   direction == 1 ? "clockwise" : "counter-clockwise");
        }
        // Нижняя грань (Down - D)
        if (key == GLFW_KEY_D) {
            scene_start_rotation(&app->scene, FACE_IDX_BOTTOM, direction, 1);
            printf("Rotating bottom face %s\n", 
                   direction == 1 ? "clockwise" : "counter-clockwise");
        }
        // Передняя грань (Front - F)
        if (key == GLFW_KEY_F) {
            scene_start_rotation(&app->scene, FACE_IDX_FRONT, direction, 1);
            printf("Rotating front face %s\n", 
                   direction == 1 ? "clockwise" : "counter-clockwise");
        }
        // Задняя грань (Back - B)
        if (key == GLFW_KEY_B) {
            scene_start_rotation(&app->scene, FACE_IDX_BACK, direction, 1);
            printf("Rotating back face %s\n", 
                   direction == 1 ? "clockwise" : "counter-clockwise");
        }
        // Левая грань (Left - L)
        if (key == GLFW_KEY_L) {
            scene_start_rotation(&app->scene, FACE_IDX_LEFT, direction, 1);
            printf("Rotating left face %s\n", 
                   direction == 1 ? "clockwise" : "counter-clockwise");
        }        
        // Правая грань (Right - R)
        if (key == GLFW_KEY_R) {
            scene_start_rotation(&app->scene, FACE_IDX_RIGHT, direction, 1);
            printf("Rotating right face %s\n", 
                   direction == 1 ? "clockwise" : "counter-clockwise");
        }


        // Сброс куба в исходное состояние
        if (key == GLFW_KEY_O) {
            const char* solidColors = "WWWWWWWWWRRRRRRRRRBBBBBBBBBOOOOOOOOOGGGGGGGGGYYYYYYYYY";
            scene_set_cube_state_from_string(&app->scene, solidColors);
        }


        // Если зажат shift, то последовательности воспроизводятся в режиме просмотра по ходам
        // Случайная последовательность ходов
        if (key == GLFW_KEY_M) {
            char** moveSequence = generate_random_move_sequence(30);
            handle_move_sequence(app, moveSequence, mods & GLFW_MOD_SHIFT, 7.0f);
        }

        // Решение куба
        if (key == GLFW_KEY_S) {
            bool isSolved = false;
            char** moveSequence = cube_solver_solve(&app->scene, &isSolved);
            if (isSolved) {
                handle_move_sequence(app, moveSequence, mods & GLFW_MOD_SHIFT, 3.0f);
            }
            else {
                printf("Not solved\n");
            }
        }

        // Примеры последовательностей ходов (Узоры)
        if (key == GLFW_KEY_1) { 
            //B F2 D' R2 F D B' F D' U F' D' L2 F D2 U'
            char* moveSequence[] = {"B", "F2", "D'", "R2", "F", "D", "B'", "F", "D'", "U", "F'", "D'", "L2", "F", "D2", "U'", NULL};
            
            handle_move_sequence(app, moveSequence, mods & GLFW_MOD_SHIFT, 3.0f);
        }
        if (key == GLFW_KEY_2) { 
            //U2 F2 R2 U' L2 D B R' B R' B R' D' L2 U'
            char* moveSequence[] = {"U2", "F2", "R2", "U'", "L2", "D", "B", "R'", "B", "R'", "B", "R'", "D'", "L2", "U'", NULL};
            
            handle_move_sequence(app, moveSequence, mods & GLFW_MOD_SHIFT, 3.0f);
        }

        // Режим раскраски
        if (key == GLFW_KEY_C) {
            scene_enter_color_mode(&app->scene, window);
        }
    }
}

// Обрабока нажатий мыши
static void mouse_button_callback(GLFWwindow* handle, int button, int action, int mods) {
    Window* window = (Window*)glfwGetWindowUserPointer(handle);
    struct Application* app = window->app;

    // Отключить вращение мышью в режиме раскраски 
    if (button == GLFW_MOUSE_BUTTON_LEFT) {
        if (action == GLFW_PRESS && !scene_is_in_color_mode(&app->scene)) {
            camera_start_drag(&window->camera, window->mouseX, window->mouseY);
        } else if (action == GLFW_RELEASE) {
            camera_end_drag(&window->camera);
        }
    }
}

// Обрабока движения мыши
static void cursor_pos_callback(GLFWwindow* handle, double xpos, double ypos) {
    Window* window = (Window*)glfwGetWindowUserPointer(handle);

    // Отключить движения мышью в режиме раскраски
    if (!scene_is_in_color_mode(&window->app->scene)){
        // Обновление текущей позиции мыши
        window->mouseX = xpos;
        window->mouseY = ypos;
        
        // Обрабока движения мыши для камеры
        camera_process_mouse_movement(&window->camera, xpos, ypos);
    }
}

// Обработка колесика мыши
static void scroll_callback(GLFWwindow* handle, double xoffset, double yoffset) {
    Window* window = (Window*)glfwGetWindowUserPointer(handle);
    struct Application* app = window->app;
    // Process scroll for camera zoom
    camera_process_scroll(&window->camera, yoffset);
}

// Инициализация окна 
bool window_init(Window* window, int width, int height, const char* title) {
    if (!glfwInit()) {
        fprintf(stderr, "Failed to initialize GLFW\n");
        return false;
    }

    // Request OpenGL 3.3 core profile
    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 3);
    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 3);
    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);
    
    // Включить MSAA (Multi-Sample Anti-Aliasing) 4x
    glfwWindowHint(GLFW_SAMPLES, 4);

    window->handle = glfwCreateWindow(width, height, title, NULL, NULL);
    window->width = width;
    window->height = height;
    window->title = title;
    window->shouldClose = false;
    window->mouseX = 0.0;
    window->mouseY = 0.0;
    
    // Инициализация камеры
    camera_init(&window->camera);

    if (!window->handle) {
        fprintf(stderr, "Failed to create GLFW window\n");
        glfwTerminate();
        return false;
    }

    glfwSetWindowUserPointer(window->handle, window);
    glfwMakeContextCurrent(window->handle);
    glfwSetFramebufferSizeCallback(window->handle, framebuffer_size_callback);
    glfwSetKeyCallback(window->handle, key_callback);
    glfwSetMouseButtonCallback(window->handle, mouse_button_callback);
    glfwSetCursorPosCallback(window->handle, cursor_pos_callback);
    glfwSetScrollCallback(window->handle, scroll_callback);
    
    // VSync
    glfwSwapInterval(1);

    glewExperimental = GL_TRUE;
    if (glewInit() != GLEW_OK) {
        fprintf(stderr, "Failed to initialize GLEW\n");
        return false;
    }

    printf("OpenGL Version: %s\n", glGetString(GL_VERSION));

    glViewport(0, 0, width, height);
    
    // Включить MSAA
    glEnable(GL_MULTISAMPLE);
    
    return true;
}

// Функция которая меняет текущий буфер окна со следующим обновляя viewport
void window_swap_buffers(Window* window) {
    glfwSwapBuffers(window->handle);
    
    if (glfwWindowShouldClose(window->handle)) {
        window->shouldClose = true;
    }
}

void window_poll_events(void) {
    glfwPollEvents();
}

void window_destroy(Window* window) {
    glfwDestroyWindow(window->handle);
    glfwTerminate();
}

bool window_should_close(Window* window) {
    return window->shouldClose;
}

Camera* window_get_camera(Window* window) {
    return &window->camera;
}

./src/core/window.h:

#ifndef WINDOW_H
#define WINDOW_H

#include <GL/glew.h>
#include <GLFW/glfw3.h>
#include <stdbool.h>
#include "camera.h"
#include "../types.h"
#include "../scene/scene.h"

// Forward declarations
struct Application;

struct Window {
    GLFWwindow* handle;
    int width;
    int height;
    const char* title;
    bool shouldClose;
    
    // Координаты мыши
    double mouseX;
    double mouseY;
    
    // Инстанс камеры
    Camera camera;
    
    // Поинтер на родительское приложение для управления кнопками
    struct Application* app;
};

bool window_init         (Window* window, int width, int height, const char* title);
void window_swap_buffers (Window* window);
void window_poll_events  (void);
void window_destroy      (Window* window);
bool window_should_close (Window* window);

// Get camera-related information
Camera* window_get_camera(Window* window);

#endif /* WINDOW_H */

./src/main.c:

#include "core/application.h"
#include <stdio.h>

static void display_help_message();

int main() {
    Application app;
    
    if (!application_init(&app)) {
        fprintf(stderr, "Failed to initialize application\n");
        return -1;
    }
    
    display_help_message();

    application_run(&app);
    
    application_cleanup(&app);
    
    return 0;
} 

static void display_help_message(){
    printf("\n=== Rubik's Cube Controls ===\n");
    printf("Camera Controls:\n");
    printf("  - Left Mouse Button: Rotate camera view\n");
    printf("  - Mouse Wheel: Zoom in/out\n");
    printf("  - +/-: Adjust field of view\n");
    printf("  - 0: Reset field of view to default\n");
    printf("\n");
    printf("Cube Controls:\n");
    printf("  - U: Rotate top face clockwise\n");
    printf("  - D: Rotate bottom face clockwise\n");
    printf("  - F: Rotate front face clockwise\n");
    printf("  - B: Rotate back face clockwise\n");
    printf("  - L: Rotate left face clockwise\n");
    printf("  - R: Rotate right face clockwise\n");
    printf("  - Shift + Letter: Rotate counter-clockwise\n");
    printf("\n");
    printf("Move sequence controls: \n");
    printf("  - O: Reset cube to solved state\n");
    printf("  - M: Scramble cube\n");
    printf("  - S: Solve cube\n");
    printf("  - 1-2: Patterns\n");
    printf("  - Shift + Char: Play sequence in browse mode\n");
    printf("\n");
    printf("Browse mode controls: \n");
    printf("  - Left/Right Arrow Keys: Rotate camera view\n");
    printf("  - Shift + Up/Down Arrow Keys: Zoom in/out\n");
    printf("  - ESC: Exit browse mode\n");
    printf("\n");
    printf("Color mode controls\n");
    printf("  - 1-6: Set Color for selected element\n");
    printf("  - Left/Right Arrow Keys: Switch between faces\n");
    printf("  - C: Enter/Exit color mode\n\n");
}

./src/math/mat4.c:

#include "mat4.h"
#include <math.h>
#include <string.h>

// Создание единичной матрицы 4х4
Mat4 mat4_identity(void) {
    Mat4 result;
    memset(result.elements, 0, sizeof(float) * 16);

    result.elements[0] = 1.0f;
    result.elements[5] = 1.0f;
    result.elements[10] = 1.0f;
    result.elements[15] = 1.0f;
    
    return result;
}

// Создает матрицу перемещения на заданные координаты
Mat4 mat4_translation(float x, float y, float z) {
    Mat4 result = mat4_identity();
    
    result.elements[12] = x;
    result.elements[13] = y;
    result.elements[14] = z;
    
    return result;
}

// Переместить на заданные координаты
Mat4 mat4_translate(Mat4 mat, Vec3 translation) {
    Mat4 trans = mat4_translation(translation.x, translation.y, translation.z);
    
    return mat4_multiply(mat, trans);
}

// Создание матрицы поворота на заданный угол в радианах по x
Mat4 mat4_rotation_x(float radians) {
    Mat4 result = mat4_identity();
    
    float cos_result = cosf(radians);
    float sin_result = sinf(radians);
    
    result.elements[5] = cos_result;
    result.elements[6] = sin_result;
    result.elements[9] = -sin_result;
    result.elements[10] = cos_result;
    
    return result;
}

// Создание матрицы поворота на заданный угол в радианах по y
Mat4 mat4_rotation_y(float radians) {
    Mat4 result = mat4_identity();
    
    float cos_result = cosf(radians);
    float sin_result = sinf(radians);
    
    result.elements[0] = cos_result;
    result.elements[2] = -sin_result;
    result.elements[8] = sin_result;
    result.elements[10] = cos_result;
    
    return result;
}

// Создание матрицы поворота на заданный угол в радианах по z
Mat4 mat4_rotation_z(float radians) {
    Mat4 result = mat4_identity();
    
    float cos_result = cosf(radians);
    float sin_result = sinf(radians);
    
    result.elements[0] = cos_result;
    result.elements[1] = sin_result;
    result.elements[4] = -sin_result;
    result.elements[5] = cos_result;
    
    return result;
}

// Создание матрицы масштабирования по осям
Mat4 mat4_scale(float x, float y, float z) {
    Mat4 result = mat4_identity();
    
    result.elements[0] = x;
    result.elements[5] = y;
    result.elements[10] = z;
    
    return result;
}

// Маштабировать mat по Vec3 scale
Mat4 mat4_scale_vec3(Mat4 mat, Vec3 scale) {
    Mat4 scaling = mat4_scale(scale.x, scale.y, scale.z);
    return mat4_multiply(mat, scaling);
}

// Создание матрицы перспективы
Mat4 mat4_perspective(float fov, float aspect, float near, float far) {
    Mat4 result;
    memset(result.elements, 0, sizeof(float) * 16);
    
    float tan_half_fov = tanf(fov / 2.0f);
    float range = near - far;
    
    result.elements[0] = 1.0f / (aspect * tan_half_fov);
    result.elements[5] = 1.0f / tan_half_fov;
    result.elements[10] = (near + far) / range;
    result.elements[11] = -1.0f;
    result.elements[14] = (2.0f * near * far) / range;
    
    return result;
}

// Проекция со стороны камеры
Mat4 mat4_look_at(Vec3 eye, Vec3 center, Vec3 up) {
    Mat4 result;
    
    Vec3 f = vec3_normalize(vec3_sub(center, eye));
    Vec3 s = vec3_normalize(vec3_cross(f, up));
    Vec3 u = vec3_cross(s, f);
    
    result.elements[0] = s.x;
    result.elements[4] = s.y;
    result.elements[8] = s.z;
    
    result.elements[1] = u.x;
    result.elements[5] = u.y;
    result.elements[9] = u.z;
    
    result.elements[2] = -f.x;
    result.elements[6] = -f.y;
    result.elements[10] = -f.z;
    
    result.elements[12] = -vec3_dot(s, eye);
    result.elements[13] = -vec3_dot(u, eye);
    result.elements[14] = vec3_dot(f, eye);
    
    result.elements[3] = 0.0f;
    result.elements[7] = 0.0f;
    result.elements[11] = 0.0f;
    result.elements[15] = 1.0f;
    
    return result;
}

// Умножение двух матриц
Mat4 mat4_multiply(Mat4 a, Mat4 b) {
    Mat4 result;
    
    for (int row = 0; row < 4; row++) {
        for (int col = 0; col < 4; col++) {
            float sum = 0.0f;
            for (int i = 0; i < 4; i++) {
                sum += mat4_get_element(a, row, i) * mat4_get_element(b, i, col);
            }
            mat4_set_element(&result, row, col, sum);
        }
    }
    
    return result;
}

// Порядок элементов по столбцам
void mat4_set_element(Mat4* mat, int row, int col, float value) {
    mat->elements[col * 4 + row] = value;
}

float mat4_get_element(Mat4 mat, int row, int col) {
    return mat.elements[col * 4 + row];
} 

./src/math/mat4.h:

#ifndef MAT4_H
#define MAT4_H

#include "vec3.h"
#include <stdbool.h>

typedef struct {
    float elements[16];
} Mat4;

// Создание матриц
Mat4 mat4_identity    (void);
Mat4 mat4_translation (float x, float y, float z);
Mat4 mat4_translate   (Mat4 mat, Vec3 translation);
Mat4 mat4_rotation_x  (float radians);
Mat4 mat4_rotation_y  (float radians);
Mat4 mat4_rotation_z  (float radians);
Mat4 mat4_scale       (float x, float y, float z);
Mat4 mat4_scale_vec3  (Mat4 mat, Vec3 scale);
Mat4 mat4_perspective (float fov, float aspect, float near, float far);
Mat4 mat4_look_at     (Vec3 eye, Vec3 center, Vec3 up);

// Операции над матрицами
Mat4 mat4_multiply     (Mat4 a, Mat4 b);
void mat4_set_element  (Mat4* mat, int row, int col, float value);
float mat4_get_element (Mat4 mat, int row, int col);

#endif /* MAT4_H */ 

./src/math/vec2.c:

#include "vec2.h"
#include <math.h>

Vec2 vec2_create(float x, float y) {
    Vec2 result = {x, y};
    return result;
}

Vec2 vec2_add(Vec2 a, Vec2 b) {
    Vec2 result = {a.x + b.x, a.y + b.y};
    return result;
}

Vec2 vec2_sub(Vec2 a, Vec2 b) {
    Vec2 result = {a.x - b.x, a.y - b.y};
    return result;
}

Vec2 vec2_mul(Vec2 a, float scalar) {
    Vec2 result = {a.x * scalar, a.y * scalar};
    return result;
}

float vec2_dot(Vec2 a, Vec2 b) {
    return a.x * b.x + a.y * b.y;
}

float vec2_length(Vec2 v) {
    return sqrtf(v.x * v.x + v.y * v.y);
}

Vec2 vec2_normalize(Vec2 v) {
    float length = vec2_length(v);
    if (length < 0.0001f) {
        return vec2_create(0.0f, 0.0f);
    }
    Vec2 result = {v.x / length, v.y / length};
    return result;
} 

./src/math/vec2.h:

#ifndef VEC2_H
#define VEC2_H

typedef struct {
    float x;
    float y;
} Vec2;

Vec2  vec2_create(float x, float y);
Vec2  vec2_add(Vec2 a, Vec2 b);
Vec2  vec2_sub(Vec2 a, Vec2 b);
Vec2  vec2_mul(Vec2 a, float scalar);
float vec2_dot(Vec2 a, Vec2 b);
float vec2_length(Vec2 v);
Vec2  vec2_normalize(Vec2 v);

#endif /* VEC2_H */ 

./src/math/vec3.c:

#include "vec3.h"
#include <math.h>

Vec3 vec3_create(float x, float y, float z) {
    Vec3 result = {x, y, z};
    return result;
}

Vec3 vec3_add(Vec3 a, Vec3 b) {
    Vec3 result = {a.x + b.x, a.y + b.y, a.z + b.z};
    return result;
}

Vec3 vec3_sub(Vec3 a, Vec3 b) {
    Vec3 result = {a.x - b.x, a.y - b.y, a.z - b.z};
    return result;
}

Vec3 vec3_mul(Vec3 a, float scalar) {
    Vec3 result = {a.x * scalar, a.y * scalar, a.z * scalar};  
    return result;
}

Vec3 vec3_div(Vec3 a, float scalar) {
    Vec3 result = {a.x / scalar, a.y / scalar, a.z / scalar};
    return result;
}

// Векторное произведение векторов
Vec3 vec3_cross(Vec3 a, Vec3 b) {
    Vec3 result;
    result.x = a.y * b.z - a.z * b.y;
    result.y = a.z * b.x - a.x * b.z;
    result.z = a.x * b.y - a.y * b.x;
    return result;
}

// Скалярное произведение
float vec3_dot(Vec3 a, Vec3 b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

float vec3_length(Vec3 v) {
    return sqrtf(v.x * v.x + v.y * v.y + v.z * v.z);
}

Vec3 vec3_normalize(Vec3 v) {
    float length = vec3_length(v);
    if (length < 0.0001f) {
        return vec3_create(0.0f, 0.0f, 0.0f);
    }
    Vec3 result = {v.x / length, v.y / length, v.z / length};
    return result;
}

// Точка на t*100% между векторами 
Vec3 vec3_lerp(Vec3 a, Vec3 b, float t) {
    Vec3 result = {a.x + t * (b.x - a.x), a.y + t * (b.y - a.y), a.z + t * (b.z - a.z)};
    return result;
}

./src/math/vec3.h:

#ifndef VEC3_H
#define VEC3_H

#include <math.h>

typedef struct {
    float x, y, z;
} Vec3;

Vec3 vec3_create    (float x, float y, float z);
Vec3 vec3_add       (Vec3 a, Vec3 b);
Vec3 vec3_sub       (Vec3 a, Vec3 b);
Vec3 vec3_mul       (Vec3 a, float scalar);
Vec3 vec3_div       (Vec3 a, float scalar);
Vec3 vec3_cross     (Vec3 a, Vec3 b);
float vec3_dot      (Vec3 a, Vec3 b);
float vec3_length   (Vec3 v);
Vec3 vec3_normalize (Vec3 v);
Vec3 vec3_lerp      (Vec3 a, Vec3 b, float t);

#endif /* VEC3_H */

./src/renderer/mesh.c:

#include "mesh.h"
#include "texture.h"
#include "../scene/scene.h"
#include <stdio.h>
#include <stdlib.h>


// Инициализация 
bool mesh_init(Mesh* mesh) {
    // Создаем VAO, VBO, EBO 
    glGenVertexArrays(1, &mesh->VAO);
    glGenBuffers(1, &mesh->VBO);
    glGenBuffers(1, &mesh->EBO);
    
    mesh->hasTexture = true;
    mesh->textureType = TEXTURE_STICKER;
    
    return true;
}

void mesh_bind(Mesh* mesh) {
    glBindVertexArray(mesh->VAO);
}

void mesh_unbind(void) {
    glBindVertexArray(0);
}

void mesh_draw(Mesh* mesh) {
    mesh_bind(mesh);
    
    // Если у меша есть текстура, то подключаемся
    if (mesh->hasTexture) {
        Texture* texture = texture_get(mesh->textureType);
        if (texture) {
            texture_bind(texture, 0);
        }
    }
    
    if (mesh->indexCount > 0) {
        glDrawElements(mesh->drawMode, mesh->indexCount, GL_UNSIGNED_INT, 0);
    } else {
        glDrawArrays(mesh->drawMode, 0, mesh->vertexCount);
    }
    
    // Отключить текстуру после подключения
    if (mesh->hasTexture) {
        texture_unbind(0);
    }
    
    mesh_unbind();
}

void mesh_destroy(Mesh* mesh) {
    glDeleteVertexArrays(1, &mesh->VAO);
    glDeleteBuffers(1, &mesh->VBO);
    glDeleteBuffers(1, &mesh->EBO);
    
    mesh->vertexCount = 0;
    mesh->indexCount = 0;
}   

Mesh create_custom_colored_cube(unsigned int visibleFaces, RGBColor (*cubeColors)[9], int x, int y, int z) {
    Mesh mesh;
    mesh_init(&mesh);
    
    // Черный для невидимых граней
    float black[3] = {0.05f, 0.05f, 0.05f};
    
    // Определение цвета на основании видимых граней и цветов из сохраненных
    RGBColor frontColor = (visibleFaces & FACE_FRONT) ? 
        cubeColors[FACE_IDX_FRONT][x + (2-y)*3] : 
        (RGBColor){black[0], black[1], black[2]};
    
    RGBColor backColor = (visibleFaces & FACE_BACK) ? 
        cubeColors[FACE_IDX_BACK][(2-x) + (2-y)*3] : 
        (RGBColor){black[0], black[1], black[2]};
    
    RGBColor topColor = (visibleFaces & FACE_TOP) ? 
        cubeColors[FACE_IDX_TOP][x + (2-z)*3] : 
        (RGBColor){black[0], black[1], black[2]};
    
    RGBColor bottomColor = (visibleFaces & FACE_BOTTOM) ? 
        cubeColors[FACE_IDX_BOTTOM][x + z*3] : 
        (RGBColor){black[0], black[1], black[2]};
    
    RGBColor rightColor = (visibleFaces & FACE_RIGHT) ? 
        cubeColors[FACE_IDX_RIGHT][z + (2-y)*3] : 
        (RGBColor){black[0], black[1], black[2]};
    
    RGBColor leftColor = (visibleFaces & FACE_LEFT) ? 
        cubeColors[FACE_IDX_LEFT][(2-z) + (2-y)*3] : 
        (RGBColor){black[0], black[1], black[2]};
    
    // Координаты (x,y,z), Цвет (r,g,b), Углы текстуры
    float vertices[] = {
        // Front face
        -0.5f, -0.5f,  0.5f,  frontColor.r, frontColor.g, frontColor.b,  0.0f, 0.0f,
         0.5f, -0.5f,  0.5f,  frontColor.r, frontColor.g, frontColor.b,  1.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  frontColor.r, frontColor.g, frontColor.b,  1.0f, 1.0f,
        -0.5f,  0.5f,  0.5f,  frontColor.r, frontColor.g, frontColor.b,  0.0f, 1.0f,
        
        // Back face
        -0.5f, -0.5f, -0.5f,  backColor.r, backColor.g, backColor.b,  0.0f, 0.0f,
         0.5f, -0.5f, -0.5f,  backColor.r, backColor.g, backColor.b,  1.0f, 0.0f,
         0.5f,  0.5f, -0.5f,  backColor.r, backColor.g, backColor.b,  1.0f, 1.0f,
        -0.5f,  0.5f, -0.5f,  backColor.r, backColor.g, backColor.b,  0.0f, 1.0f,
        
        // Top face
        -0.5f,  0.5f,  0.5f,  topColor.r, topColor.g, topColor.b,  0.0f, 0.0f,
         0.5f,  0.5f,  0.5f,  topColor.r, topColor.g, topColor.b,  1.0f, 0.0f,
         0.5f,  0.5f, -0.5f,  topColor.r, topColor.g, topColor.b,  1.0f, 1.0f,
        -0.5f,  0.5f, -0.5f,  topColor.r, topColor.g, topColor.b,  0.0f, 1.0f,
        
        // Bottom face
        -0.5f, -0.5f,  0.5f,  bottomColor.r, bottomColor.g, bottomColor.b,  0.0f, 0.0f,
         0.5f, -0.5f,  0.5f,  bottomColor.r, bottomColor.g, bottomColor.b,  1.0f, 0.0f,
         0.5f, -0.5f, -0.5f,  bottomColor.r, bottomColor.g, bottomColor.b,  1.0f, 1.0f,
        -0.5f, -0.5f, -0.5f,  bottomColor.r, bottomColor.g, bottomColor.b,  0.0f, 1.0f,
        
        // Right face
         0.5f, -0.5f,  0.5f,  rightColor.r, rightColor.g, rightColor.b,  0.0f, 0.0f,
         0.5f, -0.5f, -0.5f,  rightColor.r, rightColor.g, rightColor.b,  1.0f, 0.0f,
         0.5f,  0.5f, -0.5f,  rightColor.r, rightColor.g, rightColor.b,  1.0f, 1.0f,
         0.5f,  0.5f,  0.5f,  rightColor.r, rightColor.g, rightColor.b,  0.0f, 1.0f,
        
        // Left face
        -0.5f, -0.5f, -0.5f,  leftColor.r, leftColor.g, leftColor.b,  0.0f, 0.0f,
        -0.5f, -0.5f,  0.5f,  leftColor.r, leftColor.g, leftColor.b,  1.0f, 0.0f,
        -0.5f,  0.5f,  0.5f,  leftColor.r, leftColor.g, leftColor.b,  1.0f, 1.0f,
        -0.5f,  0.5f, -0.5f,  leftColor.r, leftColor.g, leftColor.b,  0.0f, 1.0f
    };
    
    
    // Треугольные полигоны
    unsigned int indices[] = {
        // Front face
        0, 1, 2,
        2, 3, 0,
        
        // Back face
        4, 5, 6,
        6, 7, 4,
        
        // Top face
        8, 9, 10,
        10, 11, 8,
        
        // Bottom face
        12, 13, 14,
        14, 15, 12,
        
        // Right face
        16, 17, 18,
        18, 19, 16,
        
        // Left face
        20, 21, 22,
        22, 23, 20
    };
    
    mesh.vertexCount = 24;  // 6 граней, 4 вершины на грань
    mesh.indexCount = 36;   // 12 полигонов, по 2 на грань
    mesh.drawMode = GL_TRIANGLES;
    mesh.hasTexture = true;
    
    // Вид текстуры будет определен во время создания куба в сцене
    mesh.textureType = TEXTURE_STICKER; 
    
    // Подключаемся к буферу VAO
    glBindVertexArray(mesh.VAO);
    
    // Подключаемся и задаем позиции вершин
    glBindBuffer(GL_ARRAY_BUFFER, mesh.VBO);
    glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);
    
    // Подключаемся и задаем позиции полигонов
    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, mesh.EBO);
    glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);
    
    // Конфигурация позиции координат в нашей структуре
    glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)0);
    // Вклочаем layout (location = 0) для использования в шейдерах для обращения к координатам
    glEnableVertexAttribArray(0);
    
    // Конфигурация позиции цвета в нашей структуре
    glVertexAttribPointer(1, 3, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(3 * sizeof(float)));
    glEnableVertexAttribArray(1);
    
    // Конфигурация позиции текстуры в нашей структуре
    glVertexAttribPointer(2, 2, GL_FLOAT, GL_FALSE, 8 * sizeof(float), (void*)(6 * sizeof(float)));
    glEnableVertexAttribArray(2);
    
    // Отключение от буферов
    glBindBuffer(GL_ARRAY_BUFFER, 0);
    glBindVertexArray(0);
    
    return mesh;
}

./src/renderer/mesh.h:

#ifndef MESH_H
#define MESH_H

#include <GL/glew.h>
#include <stdbool.h>

#include "texture.h"

typedef struct {
    float r, g, b;
} RGBColor;

typedef enum {
    FACE_FRONT  = 0x01,
    FACE_BACK   = 0x02,
    FACE_TOP    = 0x04,
    FACE_BOTTOM = 0x08,
    FACE_RIGHT  = 0x10,
    FACE_LEFT   = 0x20,
    FACE_ALL    = 0x3F
} CubeFace;

typedef struct {
    GLuint VAO;        // Vertex Array Object
    GLuint VBO;        // Vertex Buffer Object
    GLuint EBO;        // Element Buffer Object
    int vertexCount;  
    int indexCount;
    GLenum drawMode;   
    bool hasTexture;   
    TextureType textureType; 
} Mesh;

bool mesh_init        (Mesh* mesh);
void mesh_bind        (Mesh* mesh);
void mesh_unbind      (void);
void mesh_draw        (Mesh* mesh);
void mesh_destroy     (Mesh* mesh);

Mesh create_custom_colored_cube(unsigned int visibleFaces, RGBColor (*cubeColors)[9], int x, int y, int z);
#endif /* MESH_H */ 

./src/renderer/shader.c:

#include "shader.h"
#include <stdio.h>
#include <stdlib.h>

bool shader_init_from_source(Shader* shader, const char* vertexSource, const char* fragmentSource) {
    // Компиляция шейдеров
    GLuint vertex, fragment;
    int success;
    char infoLog[512];
    
    // Щейдер Вершин
    vertex = glCreateShader(GL_VERTEX_SHADER);
    glShaderSource(vertex, 1, &vertexSource, NULL);
    glCompileShader(vertex);
    
    // Проверка на ошибки компиляции
    glGetShaderiv(vertex, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(vertex, 512, NULL, infoLog);
        fprintf(stderr, "ERROR::SHADER::VERTEX::COMPILATION_FAILED\n%s\n", infoLog);
        return false;
    }
    
    // Шейдер фрагментов
    fragment = glCreateShader(GL_FRAGMENT_SHADER);
    glShaderSource(fragment, 1, &fragmentSource, NULL);
    glCompileShader(fragment);
    
    // Проверка на ошибки компиляции
    glGetShaderiv(fragment, GL_COMPILE_STATUS, &success);
    if (!success) {
        glGetShaderInfoLog(fragment, 512, NULL, infoLog);
        fprintf(stderr, "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n%s\n", infoLog);
        glDeleteShader(vertex);
        return false;
    }
    
    // Шейдер-программа
    shader->id = glCreateProgram();
    glAttachShader(shader->id, vertex);
    glAttachShader(shader->id, fragment);
    glLinkProgram(shader->id);
    
    // Проверка на ошибки линковки
    glGetProgramiv(shader->id, GL_LINK_STATUS, &success);
    if (!success) {
        glGetProgramInfoLog(shader->id, 512, NULL, infoLog);
        fprintf(stderr, "ERROR::SHADER::PROGRAM::LINKING_FAILED\n%s\n", infoLog);
        glDeleteShader(vertex);
        glDeleteShader(fragment);
        return false;
    }
    
    // Освободить шейдеры
    glDeleteShader(vertex);
    glDeleteShader(fragment);
    
    return true;
}

void shader_use(Shader* shader) {
    glUseProgram(shader->id);
}

void shader_destroy(Shader* shader) {
    glDeleteProgram(shader->id);
}

void shader_set_bool(Shader* shader, const char* name, bool value) {
    glUniform1i(glGetUniformLocation(shader->id, name), (int)value);
}

void shader_set_int(Shader* shader, const char* name, int value) {
    glUniform1i(glGetUniformLocation(shader->id, name), value);
}

void shader_set_float(Shader* shader, const char* name, float value) {
    glUniform1f(glGetUniformLocation(shader->id, name), value);
}

void shader_set_mat4(Shader* shader, const char* name, Mat4 value) {
    glUniformMatrix4fv(glGetUniformLocation(shader->id, name), 1, GL_FALSE, value.elements);
} 

./src/renderer/shader.h:

#ifndef SHADER_H
#define SHADER_H

#include <GL/glew.h>
#include <stdbool.h>
#include "../math/mat4.h"

typedef struct {
    GLuint id;
} Shader;

bool shader_init_from_source (Shader* shader, const char* vertexSource, const char* fragmentSource);
void shader_use              (Shader* shader);
void shader_destroy          (Shader* shader);
void shader_set_bool         (Shader* shader, const char* name, bool value);
void shader_set_int          (Shader* shader, const char* name, int value);
void shader_set_float        (Shader* shader, const char* name, float value);
void shader_set_mat4         (Shader* shader, const char* name, Mat4 value);

#endif /* SHADER_H */ 

./src/renderer/texture.c:

#include "texture.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Используется STB Image для того чтобы загрузить файлы текстур
#define STB_IMAGE_IMPLEMENTATION
#include <STB/stb_image.h>
#include <GL/glew.h>

// Текстуры в бинарном виде
#include "../resources/embedded_textures.h"

// Глобальное хранилище текстур
static Texture textures[TEXTURE_COUNT];
static bool textures_initialized = false;

// map texturetype to raw data
typedef struct {
    const unsigned char* data;
    unsigned int size;
} EmbeddedTextureData;

// массив данных
static EmbeddedTextureData embedded_textures[TEXTURE_COUNT];

static const char* texture_names[TEXTURE_COUNT] = {
    "stickerCenter.png",
    "sticker.png"
};

static void init_embedded_textures(void) {
    embedded_textures[TEXTURE_STICKER_CENTER].data = stickerCenter_png;
    embedded_textures[TEXTURE_STICKER_CENTER].size = stickerCenter_png_size;
    
    embedded_textures[TEXTURE_STICKER].data = sticker_png;
    embedded_textures[TEXTURE_STICKER].size = sticker_png_size;
}

// Загрузить текстуру из raw_data в массив
static bool load_texture(TextureType type) {
    Texture* texture = &textures[type];
    const EmbeddedTextureData* tex_data = &embedded_textures[type];
    const char* filename = texture_names[type]; 
    
    // Создаем текстуру
    glGenTextures(1, &texture->id);
    glBindTexture(GL_TEXTURE_2D, texture->id);
    
    // Парметры текстуры
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR_MIPMAP_LINEAR);
    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
    
    stbi_set_flip_vertically_on_load(1); 
    
    // Загружаем из пемяти библиотекой
    unsigned char* data = stbi_load_from_memory(
        tex_data->data, tex_data->size,
        &texture->width, &texture->height, &texture->channels, 0
    );
    
    // Ошибки
    const char* error_msg = stbi_failure_reason();
    
    if (!data) {
        fprintf(stderr, "Failed to load embedded texture: %s\n", filename);
        fprintf(stderr, "STB error: %s\n", error_msg ? error_msg : "Unknown error");
        glDeleteTextures(1, &texture->id);
        texture->id = 0;
        return false;
    }
    
    // Determine format based on number of channels
    GLenum format;
    switch (texture->channels) {
        case 1:
            format = GL_RED;
            break;
        case 3:
            format = GL_RGB;
            break;
        case 4:
            format = GL_RGBA;
            break;
        default:
            fprintf(stderr, "Unsupported channel format (%d) in texture: %s\n", texture->channels, filename);
            stbi_image_free(data);
            glDeleteTextures(1, &texture->id);
            texture->id = 0;
            return false;
    }
    
    // Upload texture data to GPU
    glTexImage2D(GL_TEXTURE_2D, 0, format, texture->width, texture->height, 0, format, GL_UNSIGNED_BYTE, data);
    glGenerateMipmap(GL_TEXTURE_2D);
    
    // Free image data
    stbi_image_free(data);
    
    printf("Loaded embedded texture '%s' (%dx%d, %d channels)\n", filename, texture->width, texture->height, texture->channels);
    return true;
}

// Initialize the texture system
bool texture_init_system(void) {
    if (textures_initialized) {
        return true;
    }
    
    // Initialize textures array
    memset(textures, 0, sizeof(textures));
    
    // Initialize embedded textures
    init_embedded_textures();
    
    // Load all textures
    int loaded_count = 0;
    for (int i = 0; i < TEXTURE_COUNT; i++) {
        if (load_texture(i)) {
            loaded_count++;
        }
    }
    
    textures_initialized = true;
    printf("Texture system initialized: %d/%d textures loaded\n", loaded_count, TEXTURE_COUNT);
    return loaded_count == TEXTURE_COUNT;
}

// Clean up the texture system
void texture_cleanup_system(void) {
    if (!textures_initialized) {
        return;
    }
    
    // Delete all textures
    for (int i = 0; i < TEXTURE_COUNT; i++) {
        if (textures[i].id != 0) {
            glDeleteTextures(1, &textures[i].id);
            textures[i].id = 0;
        }
    }
    
    textures_initialized = false;
    printf("Texture system cleaned up\n");
}

// Get a texture by type
Texture* texture_get(TextureType type) {
    if (!textures_initialized || type < 0 || type >= TEXTURE_COUNT) {
        return NULL;
    }
    
    return &textures[type];
}

// Bind a texture to a texture unit
void texture_bind(Texture* texture, GLuint unit) {
    if (!texture || texture->id == 0) {
        return;
    }
    
    glActiveTexture(GL_TEXTURE0 + unit);
    glBindTexture(GL_TEXTURE_2D, texture->id);
}

// Unbind a texture from a texture unit
void texture_unbind(GLuint unit) {
    glActiveTexture(GL_TEXTURE0 + unit);
    glBindTexture(GL_TEXTURE_2D, 0);
} 

./src/renderer/texture.h:

#ifndef TEXTURE_H
#define TEXTURE_H

#include <stdbool.h>
#include <GL/glew.h>

// Texture types enum
typedef enum {
    TEXTURE_STICKER_CENTER,
    TEXTURE_STICKER,
    TEXTURE_COUNT
} TextureType;

// Texture structure
typedef struct {
    GLuint id;          // OpenGL texture ID
    int width;          // Texture width
    int height;         // Texture height
    int channels;       // Number of color channels
} Texture;

// Initialize the texture system and load all textures
bool texture_init_system(void);

// Clean up the texture system
void texture_cleanup_system(void);

// Get a texture by type
Texture* texture_get(TextureType type);

// Bind a texture to a texture unit
void texture_bind(Texture* texture, GLuint unit);

// Unbind a texture from a texture unit
void texture_unbind(GLuint unit);

#endif // TEXTURE_H 

./src/resources/embedded_shaders.h:

#ifndef EMBEDDED_SHADERS_H
#define EMBEDDED_SHADERS_H

// Шейдер вершин с текстурами
static const char* TEXTURED_VERTEX_SHADER = 
"#version 330 core\n"
"layout (location = 0) in vec3 aPos;\n"
"layout (location = 1) in vec3 aColor;\n"
"layout (location = 2) in vec2 aTexCoord;\n"
"\n"
"uniform mat4 model;\n"
"uniform mat4 view;\n"
"uniform mat4 projection;\n"
"\n"
"out vec3 vertexColor;\n"
"out vec2 texCoord;\n"
"\n"
"void main() {\n"
"    gl_Position = projection * view * model * vec4(aPos, 1.0);\n"
"    vertexColor = aColor;\n"
"    texCoord = aTexCoord;\n"
"}\n";

// Шейдер фрагментов с текстурами
static const char* TEXTURED_FRAGMENT_SHADER = 
"#version 330 core\n"
"out vec4 FragColor;\n"
"\n"
"in vec3 vertexColor;\n"
"in vec2 texCoord;\n"
"\n"
"uniform sampler2D textureMap;\n"
"uniform bool useTexture;\n"
"\n"
"void main() {\n"
"    if (useTexture) {\n"
"        FragColor = texture(textureMap, texCoord) * vec4(vertexColor, 1.0);\n"
"    } else {\n"
"        FragColor = vec4(vertexColor, 1.0);\n"
"    }\n"
"}\n";

#endif /* EMBEDDED_SHADERS_H */ 

./src/resources/embedded_textures.c:

/* Auto-generated texture data - DO NOT EDIT */

#include "embedded_textures.h"

// Generated from sticker.png
const unsigned char sticker_png[] = {
    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
    0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 
    0x08, 0x02, 0x00, 0x00, 0x00, 0x4c, 0x5c, 0xf6, 0x9c, 0x00, 0x00, 0x00, 
    0x04, 0x67, 0x41, 0x4d, 0x41, 0x00, 0x00, 0xb1, 0x8f, 0x0b, 0xfc, 0x61, 
    0x05, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0e, 
    0xc1, 0x00, 0x00, 0x0e, 0xc1, 0x01, 0xb8, 0x91, 0x6b, 0xed, 0x00, 0x00, 
    0x00, 0x18, 0x74, 0x45, 0x58, 0x74, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61, 
    0x72, 0x65, 0x00, 0x70, 0x61, 0x69, 0x6e, 0x74, 0x2e, 0x6e, 0x65, 0x74, 
    0x20, 0x34, 0x2e, 0x31, 0x2e, 0x36, 0xfd, 0x4e, 0x09, 0xe8, 0x00, 0x00, 
    0x02, 0x42, 0x49, 0x44, 0x41, 0x54, 0x78, 0x5e, 0xed, 0x91, 0x31, 0x6e, 
    0xc3, 0x30, 0x14, 0xc5, 0x52, 0xf4, 0xfe, 0x67, 0x6e, 0x1d, 0x44, 0x0b, 
    0x55, 0x27, 0x19, 0x62, 0x53, 0x70, 0x41, 0xe2, 0x8d, 0xfa, 0x83, 0xc8, 
    0xdb, 0xb5, 0xf9, 0xfe, 0xba, 0xf6, 0xfe, 0xc3, 0x1f, 0x2e, 0xbd, 0x02, 
    0x2c, 0x5e, 0x01, 0x16, 0xaf, 0x00, 0x8b, 0xf7, 0x36, 0xc0, 0x4f, 0x7c, 
    0xcc, 0xa4, 0x14, 0x7b, 0x11, 0x60, 0x5c, 0xc7, 0x41, 0x4c, 0x7a, 0xc7, 
    0x9e, 0x05, 0x18, 0x47, 0x71, 0x28, 0x93, 0xe4, 0xfb, 0x76, 0x03, 0x8c, 
    0xe7, 0x71, 0x02, 0x93, 0xea, 0x02, 0xd8, 0x4c, 0xaa, 0x77, 0x02, 0x8c, 
    0x87, 0x71, 0x1a, 0x10, 0x5e, 0x00, 0x1f, 0x08, 0x2f, 0x80, 0x0f, 0x84, 
    0x17, 0xc0, 0x07, 0xc2, 0x0b, 0xe0, 0x03, 0xe1, 0x05, 0xf0, 0x81, 0xf0, 
    0x02, 0xf8, 0x40, 0x78, 0x01, 0x7c, 0x20, 0xbc, 0x00, 0x3e, 0x10, 0x5e, 
    0x00, 0x1f, 0x08, 0x2f, 0x80, 0x0f, 0x84, 0x17, 0xc0, 0x07, 0xc2, 0x0b, 
    0xe0, 0x03, 0xe1, 0x05, 0xf0, 0x81, 0xf0, 0x02, 0xf8, 0x40, 0x78, 0x01, 
    0x7c, 0x20, 0xbc, 0x00, 0x3e, 0x10, 0x5e, 0x00, 0x1f, 0x08, 0x2f, 0x80, 
    0x0f, 0x84, 0x17, 0xc0, 0x07, 0xc2, 0x0b, 0xe0, 0x03, 0xe1, 0x05, 0xf0, 
    0x81, 0xf0, 0x02, 0xf8, 0x40, 0x78, 0x01, 0x7c, 0x20, 0xbc, 0x00, 0x3e, 
    0x10, 0x5e, 0x00, 0x1f, 0x08, 0x2f, 0x80, 0x0f, 0x84, 0x17, 0xc0, 0x07, 
    0xc2, 0x0b, 0xe0, 0x03, 0xe1, 0x05, 0xf0, 0x81, 0xf0, 0x02, 0xf8, 0x40, 
    0x78, 0x01, 0x7c, 0x20, 0xbc, 0x00, 0x3e, 0x10, 0x5e, 0x00, 0x1f, 0x08, 
    0x2f, 0x80, 0x0f, 0x84, 0x17, 0xc0, 0x07, 0xc2, 0x0b, 0xe0, 0x03, 0xe1, 
    0x05, 0xf0, 0x81, 0xf0, 0x02, 0xf8, 0x40, 0x78, 0x01, 0x7c, 0x20, 0xbc, 
    0x00, 0x3e, 0x10, 0x5e, 0x00, 0x1f, 0x08, 0x2f, 0x80, 0x0f, 0x84, 0x17, 
    0xc0, 0x07, 0xc2, 0x0b, 0xe0, 0x03, 0xe1, 0x05, 0xf0, 0x81, 0xf0, 0x02, 
    0xf8, 0x40, 0x78, 0x01, 0x7c, 0x20, 0xbc, 0x00, 0x3e, 0x10, 0x5e, 0x00, 
    0x1f, 0x08, 0x2f, 0x80, 0x0f, 0x84, 0x17, 0xc0, 0x07, 0xc2, 0x0b, 0xe0, 
    0x03, 0xe1, 0x05, 0xf0, 0x81, 0xf0, 0x02, 0xf8, 0x40, 0x78, 0x01, 0x7c, 
    0x20, 0xbc, 0x00, 0x3e, 0x10, 0x5e, 0x00, 0x1f, 0x08, 0x2f, 0x80, 0x0f, 
    0x84, 0x17, 0xc0, 0x07, 0xc2, 0x0b, 0xe0, 0x03, 0xe1, 0x05, 0xf0, 0x81, 
    0xf0, 0x02, 0xf8, 0x40, 0x78, 0x01, 0x7c, 0x20, 0xbc, 0x00, 0x3e, 0x10, 
    0x5e, 0x00, 0x1f, 0x08, 0x2f, 0x80, 0x0f, 0x84, 0x17, 0xc0, 0x07, 0xc2, 
    0x0b, 0xe0, 0x03, 0xe1, 0x05, 0xf0, 0x81, 0xf0, 0x02, 0xf8, 0x40, 0x78, 
    0x01, 0x7c, 0x20, 0xbc, 0x00, 0x3e, 0x10, 0x5e, 0x00, 0x1f, 0x08, 0x2f, 
    0x80, 0x0f, 0x84, 0x17, 0xc0, 0x07, 0xc2, 0x0b, 0xe0, 0x03, 0xe1, 0x05, 
    0xf0, 0x81, 0xf0, 0x02, 0xf8, 0x40, 0x78, 0x01, 0x7c, 0x20, 0xbc, 0x00, 
    0x3e, 0x10, 0x5e, 0x00, 0x1f, 0x08, 0x2f, 0x80, 0x0f, 0x84, 0x17, 0xc0, 
    0x07, 0xc2, 0x0b, 0xe0, 0x03, 0xe1, 0x05, 0xf0, 0x81, 0xf0, 0x02, 0xf8, 
    0x40, 0x78, 0x01, 0x7c, 0x20, 0xbc, 0x00, 0x3e, 0x10, 0x5e, 0x00, 0x1f, 
    0x08, 0x2f, 0x80, 0x0f, 0x84, 0x17, 0xc0, 0x07, 0xc2, 0x0b, 0xe0, 0x03, 
    0xe1, 0x05, 0xf0, 0x81, 0xf0, 0x02, 0xf8, 0x40, 0x78, 0x01, 0x7c, 0x20, 
    0xbc, 0x00, 0x3e, 0x10, 0x5e, 0x00, 0x1f, 0x08, 0x2f, 0x80, 0x0f, 0x84, 
    0x17, 0xc0, 0x07, 0xc2, 0x0b, 0xe0, 0x03, 0xe1, 0x05, 0xf0, 0x81, 0xf0, 
    0x02, 0xf8, 0x40, 0x78, 0x01, 0x7c, 0x20, 0xbc, 0x00, 0x3e, 0x10, 0x5e, 
    0x00, 0x1f, 0x08, 0x2f, 0x80, 0x0f, 0x84, 0x17, 0xc0, 0x07, 0xc2, 0xff, 
    0x06, 0xd8, 0x36, 0x1e, 0xc6, 0x09, 0x4c, 0xaa, 0x0b, 0x60, 0x33, 0xa9, 
    0xde, 0x0f, 0xb0, 0x6d, 0x3c, 0x8f, 0x43, 0x99, 0x24, 0xdf, 0xf7, 0x2c, 
    0xc0, 0xb6, 0x71, 0x14, 0x07, 0x31, 0xe9, 0x1d, 0x7b, 0x11, 0xe0, 0xb1, 
    0x71, 0x1d, 0x1f, 0x30, 0x29, 0xc5, 0xde, 0x06, 0x68, 0xe7, 0xae, 0x00, 
    0x8b, 0x57, 0x80, 0xc5, 0x2b, 0xc0, 0xe2, 0x5d, 0x9e, 0xe9, 0x3f, 0x97, 
    0xdb, 0xed, 0xf6, 0x0b, 0x92, 0x39, 0x26, 0x1b, 0x77, 0x5c, 0x48, 0x3d, 
    0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};
const unsigned int sticker_png_size = 708;

// Generated from stickerCenter.png
const unsigned char stickerCenter_png[] = {
    0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d, 
    0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0x80, 0x00, 0x00, 0x00, 0x80, 
    0x08, 0x02, 0x00, 0x00, 0x00, 0x4c, 0x5c, 0xf6, 0x9c, 0x00, 0x00, 0x00, 
    0x04, 0x67, 0x41, 0x4d, 0x41, 0x00, 0x00, 0xb1, 0x8f, 0x0b, 0xfc, 0x61, 
    0x05, 0x00, 0x00, 0x00, 0x09, 0x70, 0x48, 0x59, 0x73, 0x00, 0x00, 0x0e, 
    0xc1, 0x00, 0x00, 0x0e, 0xc1, 0x01, 0xb8, 0x91, 0x6b, 0xed, 0x00, 0x00, 
    0x00, 0x18, 0x74, 0x45, 0x58, 0x74, 0x53, 0x6f, 0x66, 0x74, 0x77, 0x61, 
    0x72, 0x65, 0x00, 0x70, 0x61, 0x69, 0x6e, 0x74, 0x2e, 0x6e, 0x65, 0x74, 
    0x20, 0x34, 0x2e, 0x31, 0x2e, 0x36, 0xfd, 0x4e, 0x09, 0xe8, 0x00, 0x00, 
    0x03, 0xfe, 0x49, 0x44, 0x41, 0x54, 0x78, 0x5e, 0xed, 0x91, 0xdb, 0x8e, 
    0xda, 0x00, 0x14, 0x03, 0xb7, 0xea, 0xff, 0x7f, 0xf3, 0x56, 0x89, 0x06, 
    0xe1, 0x18, 0x72, 0x8f, 0x53, 0xed, 0xe2, 0x91, 0x9f, 0x46, 0x87, 0x04, 
    0x86, 0xaf, 0x81, 0xbf, 0x7f, 0xba, 0xff, 0x33, 0x30, 0xdb, 0xdd, 0x36, 
    0x30, 0xdb, 0xdd, 0x36, 0x30, 0xdb, 0xdd, 0x36, 0x30, 0xdb, 0xdd, 0x36, 
    0x30, 0x7b, 0xe9, 0xbe, 0x7f, 0x38, 0xf6, 0x73, 0x2e, 0x1e, 0x98, 0x3d, 
    0x3d, 0xbe, 0xfb, 0xaf, 0xc3, 0x7e, 0xe6, 0x05, 0x03, 0xb3, 0x47, 0xc7, 
    0xd7, 0xfc, 0x00, 0xec, 0x87, 0x1f, 0x1f, 0x98, 0xdd, 0x3f, 0xbe, 0xd7, 
    0x87, 0x61, 0x11, 0x8e, 0x0c, 0xcc, 0xee, 0x19, 0xdf, 0xe5, 0x83, 0xb1, 
    0x20, 0xfb, 0x06, 0x66, 0xb7, 0x8d, 0xf7, 0x97, 0x11, 0x8b, 0xb3, 0x75, 
    0x60, 0x76, 0xc3, 0x78, 0x6d, 0x11, 0x2c, 0xd1, 0xa6, 0x81, 0xd9, 0xb5, 
    0xf1, 0xc2, 0xf2, 0x82, 0x85, 0x5a, 0x1f, 0x98, 0x5d, 0x1c, 0xaf, 0x2a, 
    0x33, 0x58, 0xae, 0x95, 0x81, 0xd9, 0xf9, 0xf1, 0x92, 0xb2, 0x88, 0x45, 
    0x5b, 0x1a, 0x98, 0x9d, 0x19, 0x8f, 0x2f, 0x1b, 0xb0, 0x74, 0xb3, 0x03, 
    0xb3, 0xef, 0xc6, 0x83, 0xcb, 0x66, 0x2c, 0xe0, 0xfb, 0x81, 0xd9, 0x97, 
    0xf1, 0xc8, 0xb2, 0x13, 0xcb, 0xf8, 0x66, 0x60, 0x76, 0x3a, 0x1e, 0x56, 
    0x0e, 0x61, 0x31, 0x7d, 0x60, 0x56, 0xc6, 0x63, 0xca, 0x09, 0x2c, 0xe9, 
    0x64, 0x60, 0x56, 0xc6, 0x33, 0xca, 0x09, 0x2c, 0xe9, 0x64, 0x60, 0xf6, 
    0x31, 0x1e, 0x50, 0x4e, 0x63, 0x61, 0x9f, 0x03, 0xb3, 0x8f, 0xf1, 0xe9, 
    0x72, 0x1a, 0x0b, 0xfb, 0x1c, 0x98, 0x1d, 0xc7, 0x47, 0xcb, 0x45, 0x58, 
    0x5e, 0x06, 0x66, 0xc7, 0xf1, 0xb9, 0x72, 0x11, 0x96, 0x97, 0x81, 0xd9, 
    0xd6, 0xcf, 0x60, 0x91, 0x87, 0x81, 0xd9, 0xfe, 0x01, 0x19, 0x2c, 0xf2, 
    0x30, 0x30, 0xdb, 0x3f, 0x20, 0x83, 0x45, 0x1e, 0x06, 0x53, 0xcb, 0x79, 
    0x09, 0x60, 0xa9, 0xe9, 0x6f, 0x96, 0xdb, 0x12, 0xc0, 0x52, 0xd3, 0xdf, 
    0x2c, 0xb7, 0x25, 0x80, 0xa5, 0xa6, 0xbf, 0x59, 0x6e, 0x4b, 0x00, 0x4b, 
    0x4d, 0x7f, 0x55, 0x1c, 0x96, 0x18, 0x5a, 0x9b, 0xfe, 0xaa, 0xb8, 0x2a, 
    0x31, 0xb4, 0x36, 0xfd, 0x55, 0x71, 0x55, 0x62, 0x68, 0x6d, 0xfa, 0xab, 
    0xe2, 0xaa, 0xc4, 0xd0, 0xda, 0xf4, 0x57, 0xc5, 0x55, 0x89, 0xa1, 0xb5, 
    0xe9, 0xaf, 0x8a, 0xab, 0x12, 0x43, 0x6b, 0xd3, 0x5f, 0x15, 0x57, 0x25, 
    0x86, 0xd6, 0xa6, 0xbf, 0x2a, 0xae, 0x4a, 0x0c, 0xad, 0x4d, 0x7f, 0x55, 
    0x5c, 0x95, 0x18, 0x5a, 0x9b, 0xfe, 0xaa, 0xb8, 0x2a, 0x31, 0xb4, 0x36, 
    0xfd, 0x55, 0x71, 0x55, 0x62, 0x68, 0x6d, 0xfa, 0xab, 0xe2, 0xaa, 0xc4, 
    0xd0, 0xda, 0xf4, 0x57, 0xc5, 0x55, 0x89, 0xa1, 0xb5, 0xe9, 0xaf, 0x8a, 
    0xab, 0x12, 0x43, 0x6b, 0xd3, 0x5f, 0x15, 0x57, 0x25, 0x86, 0xd6, 0xa6, 
    0xbf, 0x2a, 0xae, 0x4a, 0x0c, 0xad, 0x4d, 0x7f, 0x55, 0x5c, 0x95, 0x18, 
    0x5a, 0x9b, 0xfe, 0xaa, 0xb8, 0x2a, 0x31, 0xb4, 0x36, 0xfd, 0x55, 0x71, 
    0x55, 0x62, 0x68, 0x6d, 0xfa, 0xab, 0xe2, 0xaa, 0xc4, 0xd0, 0xda, 0xf4, 
    0x57, 0xc5, 0x55, 0x89, 0xa1, 0xb5, 0xe9, 0xaf, 0x8a, 0xab, 0x12, 0x43, 
    0x6b, 0xd3, 0x5f, 0x15, 0x57, 0x25, 0x86, 0xd6, 0xa6, 0xbf, 0x2a, 0xae, 
    0x4a, 0x0c, 0xad, 0x4d, 0x7f, 0x55, 0x5c, 0x95, 0x18, 0x5a, 0x9b, 0xfe, 
    0xaa, 0xb8, 0x2a, 0x31, 0xb4, 0x36, 0xfd, 0x55, 0x71, 0x55, 0x62, 0x68, 
    0x6d, 0xfa, 0xab, 0xe2, 0xaa, 0xc4, 0xd0, 0xda, 0xf4, 0x57, 0xc5, 0x55, 
    0x89, 0xa1, 0xb5, 0xe9, 0xaf, 0x8a, 0xab, 0x12, 0x43, 0x6b, 0xd3, 0x5f, 
    0x15, 0x57, 0x25, 0x86, 0xd6, 0xa6, 0xbf, 0x2a, 0xae, 0x4a, 0x0c, 0xad, 
    0x4d, 0x7f, 0x55, 0x5c, 0x95, 0x18, 0x5a, 0x9b, 0xfe, 0xaa, 0xb8, 0x2a, 
    0x31, 0xb4, 0x36, 0xfd, 0x55, 0x71, 0x55, 0x62, 0x68, 0x6d, 0xfa, 0xab, 
    0xe2, 0xaa, 0xc4, 0xd0, 0xda, 0xf4, 0x57, 0xc5, 0x55, 0x89, 0xa1, 0xb5, 
    0xe9, 0xaf, 0x8a, 0xab, 0x12, 0x43, 0x6b, 0xd3, 0x5f, 0x15, 0x57, 0x25, 
    0x86, 0xd6, 0xa6, 0xbf, 0x2a, 0xae, 0x4a, 0x0c, 0xad, 0x4d, 0x7f, 0x55, 
    0x5c, 0x95, 0x18, 0x5a, 0x9b, 0xfe, 0xaa, 0xb8, 0x2a, 0x31, 0xb4, 0x36, 
    0xfd, 0x55, 0x71, 0x55, 0x62, 0x68, 0x6d, 0xfa, 0xab, 0xe2, 0xaa, 0xc4, 
    0xd0, 0xda, 0xf4, 0x57, 0xc5, 0x55, 0x89, 0xa1, 0xb5, 0xe9, 0xaf, 0x8a, 
    0xab, 0x12, 0x43, 0x6b, 0xd3, 0x5f, 0x15, 0x57, 0x25, 0x86, 0xd6, 0xa6, 
    0xbf, 0x2a, 0xae, 0x4a, 0x0c, 0xad, 0x4d, 0x7f, 0x55, 0x5c, 0x95, 0x18, 
    0x5a, 0x9b, 0xfe, 0xaa, 0xb8, 0x2a, 0x31, 0xb4, 0x36, 0xfd, 0x55, 0x71, 
    0x55, 0x62, 0x68, 0x6d, 0xfa, 0xab, 0xe2, 0xaa, 0xc4, 0xd0, 0xda, 0xf4, 
    0x57, 0xc5, 0x55, 0x89, 0xa1, 0xb5, 0xe9, 0xaf, 0x8a, 0xab, 0x12, 0x43, 
    0x6b, 0xd3, 0x5f, 0x15, 0x57, 0x25, 0x86, 0xd6, 0xa6, 0xbf, 0x2a, 0xae, 
    0x4a, 0x0c, 0xad, 0x4d, 0x7f, 0x55, 0x5c, 0x95, 0x18, 0x5a, 0x9b, 0xfe, 
    0xaa, 0xb8, 0x2a, 0x31, 0xb4, 0x36, 0xfd, 0x55, 0x71, 0x55, 0x62, 0x68, 
    0x6d, 0xfa, 0xab, 0xe2, 0xaa, 0xc4, 0xd0, 0xda, 0xf4, 0x57, 0xc5, 0x55, 
    0x89, 0xa1, 0xb5, 0xe9, 0xaf, 0x8a, 0xab, 0x12, 0x43, 0x6b, 0xd3, 0x5f, 
    0x15, 0x57, 0x25, 0x86, 0xd6, 0xa6, 0xbf, 0x2a, 0xae, 0x4a, 0x0c, 0xad, 
    0x4d, 0xff, 0x89, 0xea, 0x7f, 0x90, 0xc4, 0x52, 0xd3, 0xdf, 0x2c, 0xb7, 
    0x25, 0x80, 0xa5, 0xa6, 0xbf, 0x59, 0x6e, 0x4b, 0x00, 0x4b, 0x4d, 0x7f, 
    0xb3, 0xdc, 0x96, 0x00, 0x96, 0x9a, 0xfe, 0x6e, 0xfb, 0x1f, 0x64, 0xb0, 
    0xc8, 0xc3, 0xc0, 0x6c, 0xff, 0x80, 0x0c, 0x16, 0x79, 0x18, 0x98, 0xed, 
    0x1f, 0x90, 0xc1, 0x22, 0x0f, 0x03, 0xb3, 0xe3, 0xf8, 0x50, 0xb9, 0x08, 
    0xcb, 0xcb, 0xc0, 0xec, 0x38, 0x3e, 0x57, 0x2e, 0xc2, 0xf2, 0x32, 0x30, 
    0xfb, 0x18, 0x1f, 0x2d, 0xa7, 0xb1, 0xb0, 0xcf, 0x81, 0xd9, 0xc7, 0xf8, 
    0x74, 0x39, 0x8d, 0x85, 0x7d, 0x0e, 0xcc, 0xca, 0x78, 0x40, 0x39, 0x81, 
    0x25, 0x9d, 0x0c, 0xcc, 0xca, 0x78, 0x46, 0x39, 0x81, 0x25, 0x9d, 0x0c, 
    0xcc, 0x4e, 0xc7, 0x63, 0xca, 0x21, 0x2c, 0xa6, 0x0f, 0xcc, 0xbe, 0x8c, 
    0x87, 0x95, 0x9d, 0x58, 0xc6, 0x37, 0x03, 0xb3, 0xef, 0xc6, 0x23, 0xcb, 
    0x66, 0x2c, 0xe0, 0xfb, 0x81, 0xd9, 0x99, 0xf1, 0xe0, 0xb2, 0x01, 0x4b, 
    0x37, 0x3b, 0x30, 0x3b, 0x3f, 0x1e, 0x5f, 0x16, 0xb1, 0x68, 0x4b, 0x03, 
    0xb3, 0x8b, 0xe3, 0x25, 0x65, 0x06, 0xcb, 0xb5, 0x32, 0x30, 0xbb, 0x36, 
    0x5e, 0x55, 0x5e, 0xb0, 0x50, 0xeb, 0x03, 0xb3, 0x1b, 0xc6, 0x0b, 0x8b, 
    0x60, 0x89, 0x36, 0x0d, 0xcc, 0x6e, 0x1b, 0xaf, 0x2d, 0x23, 0x16, 0x67, 
    0xeb, 0xc0, 0xec, 0x9e, 0xf1, 0xfe, 0x0f, 0xc6, 0x82, 0xec, 0x1b, 0x98, 
    0xdd, 0x3f, 0xbe, 0xcb, 0x87, 0x61, 0x11, 0x8e, 0x0c, 0xcc, 0x1e, 0x1d, 
    0xdf, 0xeb, 0x03, 0xb0, 0x1f, 0x7e, 0x7c, 0x60, 0xf6, 0xf4, 0xf8, 0x9a, 
    0xbf, 0x0e, 0xfb, 0x99, 0x17, 0x0c, 0xcc, 0x5e, 0x3a, 0xbe, 0xfb, 0x8f, 
    0xc5, 0x7e, 0xce, 0xc5, 0x03, 0xb3, 0xdd, 0x6d, 0x03, 0xb3, 0xdd, 0x6d, 
    0x03, 0xb3, 0xdd, 0x6d, 0x03, 0xb3, 0xdd, 0x6d, 0x03, 0xb3, 0xdd, 0x6d, 
    0xfb, 0xfa, 0xfa, 0x07, 0x1f, 0x91, 0x1d, 0x1d, 0x75, 0xca, 0x00, 0xee, 
    0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e, 0x44, 0xae, 0x42, 0x60, 0x82
};
const unsigned int stickerCenter_png_size = 1152;



./src/resources/embedded_textures.h:

#ifndef EMBEDDED_TEXTURES_H
#define EMBEDDED_TEXTURES_H

// This header contains the texture data embedded as byte arrays
// Generated from PNG files in src/resources/textures

// Forward declarations of texture data arrays
extern const unsigned char stickerCenter_png[];
extern const unsigned int stickerCenter_png_size;

extern const unsigned char sticker_png[];
extern const unsigned int sticker_png_size;

#endif /* EMBEDDED_TEXTURES_H */ 

./src/scene/scene.c:

#define _USE_MATH_DEFINES

#include <GL/glew.h>
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include <string.h>
#include "../core/window.h"
#include "../resources/embedded_shaders.h"
#include "scene.h"

// Определение типа элемента по позиции
static bool is_corner_piece(int x, int y, int z) {
    return (x == 0 || x == 2) && (y == 0 || y == 2) && (z == 0 || z == 2);
}

static bool is_edge_piece(int x, int y, int z) {
    int extremeCount = 0;
    if (x == 0 || x == 2) extremeCount++;
    if (y == 0 || y == 2) extremeCount++;
    if (z == 0 || z == 2) extremeCount++;
    return extremeCount == 2;
}

static bool is_center_piece(int x, int y, int z) {
    int extremeCount = 0;
    if (x == 0 || x == 2) extremeCount++;
    if (y == 0 || y == 2) extremeCount++;
    if (z == 0 || z == 2) extremeCount++;
    return extremeCount == 1;
}

// RGB из char
static RGBColor get_rgb_from_cube_color(char colorChar) {
    RGBColor rgb;
    
    switch (colorChar) {
        case CUBE_COLOR_WHITE:
            rgb.r = 1.0f; rgb.g = 1.0f; rgb.b = 1.0f;
            break;
        case CUBE_COLOR_YELLOW:
            rgb.r = 1.0f; rgb.g = 1.0f; rgb.b = 0.0f;
            break;
        case CUBE_COLOR_RED:
            rgb.r = 1.0f; rgb.g = 0.0f; rgb.b = 0.0f;
            break;
        case CUBE_COLOR_ORANGE:
            rgb.r = 1.0f; rgb.g = 0.5f; rgb.b = 0.0f;
            break;
        case CUBE_COLOR_BLUE:
            rgb.r = 0.0f; rgb.g = 0.0f; rgb.b = 1.0f;
            break;
        case CUBE_COLOR_GREEN:
            rgb.r = 0.0f; rgb.g = 0.8f; rgb.b = 0.0f;
            break;
        default:
            // Для неизвестных цветов серый
            rgb.r = 0.5f; rgb.g = 0.5f; rgb.b = 0.5f;
    }
    
    return rgb;
}

// char из RGB
static char rgb_to_char(RGBColor color) {
    const float tolerance = 0.1f;
    
    if (fabs(color.r - 1.0f) < tolerance && fabs(color.g - 1.0f) < tolerance && fabs(color.b - 1.0f) < tolerance) {
        return 'W';
    }
    else if (fabs(color.r - 1.0f) < tolerance && fabs(color.g - 1.0f) < tolerance && fabs(color.b - 0.0f) < tolerance) {
        return 'Y';
    }
    else if (fabs(color.r - 1.0f) < tolerance && fabs(color.g - 0.0f) < tolerance && fabs(color.b - 0.0f) < tolerance) {
        return 'R';
    }
    else if (fabs(color.r - 1.0f) < tolerance && fabs(color.g - 0.5f) < tolerance && fabs(color.b - 0.0f) < tolerance) {
        return 'O';
    }
    else if (fabs(color.r - 0.0f) < tolerance && fabs(color.g - 0.0f) < tolerance && fabs(color.b - 1.0f) < tolerance) {
        return 'B';
    }
    else if (fabs(color.r - 0.0f) < tolerance && fabs(color.g - 0.8f) < tolerance && fabs(color.b - 0.0f) < tolerance) {
        return 'G';
    }
    else {
        return '?';
    }
}

static void create_textured_rubiks_cube_mesh(Scene* scene) {
    // Размер кажого куба
    float size = 0.3f; 
    // Промежуток между кубами
    float gap = 0.02f;
    
    // Размер каждого куба + промежуток между ними
    float step = size + gap;
    
    // НАчальный оффсет, чтобы центровать куб
    float offset = -step;
    
    int index = 0;
    
    for (int x = 0; x < 3; x++) {
        for (int y = 0; y < 3; y++) {
            for (int z = 0; z < 3; z++) {
                // Determine which faces should be visible based on position
                unsigned int visibleFaces = 0;
                
                // Записываем в виде битовой маски
                // Передняя грань видна для z=2
                if (z == 2) visibleFaces |= FACE_FRONT;
                
                // Задняя для z = 0
                if (z == 0) visibleFaces |= FACE_BACK;
                
                if (y == 2) visibleFaces |= FACE_TOP;
                
                if (y == 0) visibleFaces |= FACE_BOTTOM;
                
                if (x == 2) visibleFaces |= FACE_RIGHT;
                
                if (x == 0) visibleFaces |= FACE_LEFT;
                
                // создаем меш куба с такими текстурами
                scene->cubes[index] = create_custom_colored_cube(visibleFaces, scene->cubeColors, x, y, z);
                
                // Если это центральный кубик, он получает текстуру центрального кубика
                if (is_center_piece(x, y, z)) {
                    scene->cubes[index].textureType = TEXTURE_STICKER_CENTER;
                } else {
                    scene->cubes[index].textureType = TEXTURE_STICKER;
                }
                
                // Сохраняем позиции кубов
                scene->positions[index][0] = offset + x * step; // X position
                scene->positions[index][1] = offset + y * step; // Y position
                scene->positions[index][2] = offset + z * step; // Z position
                
                index++;
            }
        }
    }
}

// Инициализация кубика рубика
bool scene_init_rubiks(Scene* scene) {
    scene->numCubes = 27; // 3x3x3
    
    // Инициализация параметров вращения
    scene->isRotating = false;
    scene->rotationAngle = 0.0f;
    scene->rotationTarget = 0.0f;
    scene->rotatingLayer = 0;
    scene->rotationAxis = 'y';
    scene->speedMultiplier = 1.0f; // Стандартная скороость по умолчанию
    scene->colorMode = false;
    
    // Инициализация параметров последовательности ходов
    scene_init_move_queue(scene);
    

    // Инициализация куба стандартными цветами
    // White (U)
    for (int i = 0; i < 9; i++) {
        scene->cubeColors[FACE_IDX_TOP][i] = (RGBColor){1.0f, 1.0f, 1.0f};
    }
    // Red (F)
    for (int i = 0; i < 9; i++) {
        scene->cubeColors[FACE_IDX_FRONT][i] = (RGBColor){1.0f, 0.0f, 0.0f};
    }
    // Blue (R)
    for (int i = 0; i < 9; i++) {
        scene->cubeColors[FACE_IDX_RIGHT][i] = (RGBColor){0.0f, 0.0f, 1.0f};
    }
    // Orange (B)
    for (int i = 0; i < 9; i++) {
        scene->cubeColors[FACE_IDX_BACK][i] = (RGBColor){1.0f, 0.5f, 0.0f};
    }
    // Green (L)
    for (int i = 0; i < 9; i++) {
        scene->cubeColors[FACE_IDX_LEFT][i] = (RGBColor){0.0f, 0.8f, 0.0f};
    }
    // Yellow (D)
    for (int i = 0; i < 9; i++) {
        scene->cubeColors[FACE_IDX_BOTTOM][i] = (RGBColor){1.0f, 1.0f, 0.0f};
    }

    // Инициализируем шейдеры 
    if (!shader_init_from_source(&scene->shader, TEXTURED_VERTEX_SHADER, TEXTURED_FRAGMENT_SHADER)) {
        fprintf(stderr, "Failed to initialize shader\n");
        return false;
    }

    // Выделяем память на 27 кубов
    scene->cubes = (Mesh*)malloc(scene->numCubes * sizeof(Mesh));
    if (!scene->cubes) {
        fprintf(stderr, "Failed to allocate memory for Rubik's cube meshes\n");
    }

    // Создаем 3х3 структуру кубиков
    create_textured_rubiks_cube_mesh(scene);
    
    // Включение anti-aliasing
    glEnable(GL_DEPTH_TEST);
    glEnable(GL_MULTISAMPLE);
    glEnable(GL_LINE_SMOOTH);
    glHint(GL_LINE_SMOOTH_HINT, GL_NICEST);
    glEnable(GL_POLYGON_SMOOTH);
    glHint(GL_POLYGON_SMOOTH_HINT, GL_NICEST);
    
    return true;
}

// Обновление поворота в фрейме
static void update_rotation(Scene* scene, float deltaTime) {
    if (!scene->isRotating) {
        return;
    }

    float baseRotationSpeed = 270.0f;
    float rotationSpeed = baseRotationSpeed * scene->speedMultiplier;
    
    scene->rotationAngle += rotationSpeed * deltaTime;
    
    // Если вращение завершено
    if (scene->rotationAngle >= scene->rotationTarget) {
        scene->isRotating = false;
        scene->rotationAngle = 0.0f;
        
        // Применяем вращение к цветам на кубе
        for (int i = 0; i < scene->rotationRepetitions; i++) {
            rotate_face_colors(scene->cubeColors, scene->rotatingFace, scene->rotationDirection);

            // Пересобираем куб
            for (int i = 0; i < scene->numCubes; i++) {
                mesh_destroy(&scene->cubes[i]);
            }

            create_textured_rubiks_cube_mesh(scene);(scene, scene->rotatingFace, scene->rotationDirection);
        }
    }
}

void scene_update(Scene* scene, Window* window, float deltaTime) {
    // Если куб вращается обновляем угол вращения
    update_rotation(scene, deltaTime);
    
    // Если сейчас не вращается и не в browse моде, обновляем последовательность ходов в очереди
    if (!scene->isRotating && !scene->browseMode) {
        scene_process_move_queue(scene);
    }

    // Если в режжиме раскраски обновляем движения камеры
    if (scene->colorMode) {
        camera_update_movement(window_get_camera(window), deltaTime);
    }
}

// Функция которая перерисовывает сцену
void scene_render(Scene* scene, Window* window) {
    // Очищаем экран
    glClearColor(0.1f, 0.1f, 0.1f, 1.0f);  // Темный фон
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    
    // Используем шейдер
    shader_use(&scene->shader);
    
    Camera* camera = window_get_camera(window);
    
    // Получаем матрицы вида и проекции из камеры
    Mat4 view = camera_get_view_matrix(camera);
    float aspectRatio = (float)window->width / (float)window->height;
    Mat4 projection = camera_get_projection_matrix(camera, aspectRatio);
    
    // Устанавливаем эти матрицы в шейдеры
    shader_set_mat4(&scene->shader, "view", view);
    shader_set_mat4(&scene->shader, "projection", projection);
    shader_set_int(&scene->shader, "textureMap", 0);
    shader_set_bool(&scene->shader, "useTexture", true);
    
    // Рендерим Куб
    for (int i = 0; i < scene->numCubes; i++) {
        // Обходим все x, y, z
        int x = i % 3;              // 0, 1, 2, 0, 1, 2, ...
        int y = (i / 3) % 3;        // 0, 0, 0, 1, 1, 1, ...
        int z = i / 9;              // 0, 0, 0, 0, 0, 0, ...
        
        // Проверка на является ли этот куб частью слоя который сейчас вращается
        bool isRotatingCube = false;
        if (scene->isRotating) {
            if (scene->rotationAxis == 'x') {
                isRotatingCube = (z == scene->rotatingLayer);
            } else if (scene->rotationAxis == 'y') {
                isRotatingCube = (y == scene->rotatingLayer);
            } else if (scene->rotationAxis == 'z') {
                isRotatingCube = (x == scene->rotatingLayer);
            }
        }
        
        // Создаем матрицу преобразований для этого куба
        Mat4 model = mat4_identity();
        
        // Если этот куб сейчас вращается, преобразуем матрцу, учитывая смещение и вращение куба относительно центра
        if (isRotatingCube) {
            // Угол вращения в радианах
            float angleRad = scene->rotationAngle * (float)scene->rotationDirection * -(float)M_PI / 180.0f;
            
            // Применяем вращение на основе оси вразения
            if (scene->rotationAxis == 'x') {
                Mat4 rotationMatrix = mat4_rotation_x(angleRad);
                
                // Создаем вектор на основе текущего, поворачиваем и сдвигаем (вращение вокруг центра)
                Vec3 pos = {
                    scene->positions[i][0],
                    scene->positions[i][1],
                    scene->positions[i][2]
                };
                
                Vec3 rotated;
                rotated.x = pos.x;
                rotated.y = pos.y * cosf(angleRad) - pos.z * sinf(angleRad);
                rotated.z = pos.y * sinf(angleRad) + pos.z * cosf(angleRad);
                
                // Создаем матрицу на основе новых координат
                model = mat4_translation(rotated.x, rotated.y, rotated.z);
                
                // Применяем то же вращение к углу поворота самого куба
                model = mat4_multiply(model, rotationMatrix);
                
            } else if (scene->rotationAxis == 'y') {
                Mat4 rotationMatrix = mat4_rotation_y(angleRad);
                
                Vec3 pos = {
                    scene->positions[i][0],
                    scene->positions[i][1],
                    scene->positions[i][2]
                };
                
                Vec3 rotated;
                rotated.x = pos.x * cosf(angleRad) + pos.z * sinf(angleRad);
                rotated.y = pos.y;
                rotated.z = -pos.x * sinf(angleRad) + pos.z * cosf(angleRad);
                
                model = mat4_translation(rotated.x, rotated.y, rotated.z);
                
                model = mat4_multiply(model, rotationMatrix);
                
            } else { // 'z'
                Mat4 rotationMatrix = mat4_rotation_z(angleRad);
                
                Vec3 pos = {
                    scene->positions[i][0],
                    scene->positions[i][1],
                    scene->positions[i][2]
                };
                
                Vec3 rotated;
                rotated.x = pos.x * cosf(angleRad) - pos.y * sinf(angleRad);
                rotated.y = pos.x * sinf(angleRad) + pos.y * cosf(angleRad);
                rotated.z = pos.z;
                
                model = mat4_translation(rotated.x, rotated.y, rotated.z);
                
                model = mat4_multiply(model, rotationMatrix);
            }
        } 
        // Если текущий куб не вращается, просто ставим текущую позицию в model
        else {
            model = mat4_translation(
                scene->positions[i][0],
                scene->positions[i][1],
                scene->positions[i][2]
            );
        }
        
        // Уменьшаем каждый куб
        model = mat4_scale_vec3(model, (Vec3){0.3f, 0.3f, 0.3f});
        
        // Подставляем координаты и вращение куба в шейдер
        shader_set_mat4(&scene->shader, "model", model);
        
        // Рисуем этот куб на экран
        mesh_draw(&scene->cubes[i]);
    }
}

void scene_destroy(Scene* scene) {
    // Освобождаем ресурсы
    shader_destroy(&scene->shader);
    

    // Освобождаем последовательность ходов
    scene_destroy_move_queue(scene);
    
    // Освобождаем каждый куб из грида
    for (int i = 0; i < scene->numCubes; i++) {
        mesh_destroy(&scene->cubes[i]);
    }
    
    free(scene->cubes);
    scene->cubes = NULL;
    scene->numCubes = 0;
}

// Задать позицию кубика рубика из строчки
bool scene_set_cube_state_from_string(Scene* scene, const char* state) {
    if (!scene || !state) {
        return false;
    }
    
    // Проверка на длину
    size_t len = strlen(state);
    if (len != 54) {
        fprintf(stderr, "Invalid cube state string length: %zu (expected 54)\n", len);
        return false;
    }
    
    fprintf(stderr, "Setting cube state from string: %s\n", state);
    
    const int stringToFaceMap[6] = {
        FACE_IDX_TOP,
        FACE_IDX_FRONT,
        FACE_IDX_RIGHT,
        FACE_IDX_BACK,
        FACE_IDX_LEFT,
        FACE_IDX_BOTTOM,
    };
    
    // Убираем все старые кубики
    for (int i = 0; i < scene->numCubes; i++) {
        mesh_destroy(&scene->cubes[i]);
    }
    
    for (int stringFace = 0; stringFace < 6; stringFace++) {
        int faceIndex = stringToFaceMap[stringFace];
        
        for (int pos = 0; pos < 9; pos++) {
            char colorChar = state[stringFace * 9 + pos];
            
            // to_uppercase
            colorChar = (colorChar >= 'a' && colorChar <= 'z') ? 
                        (char)(colorChar - 'a' + 'A') : colorChar;
            
            scene->cubeColors[faceIndex][pos] = get_rgb_from_cube_color(colorChar);
        }
    }
    
    create_textured_rubiks_cube_mesh(scene);
    
    return true;
}

// Получить позицию кубика в срочку
char* scene_get_cube_state_as_string(RGBColor (*cubeColors)[9]) {
    if (!cubeColors) {
        return NULL;
    }
    
    char* state = (char*)malloc(55 * sizeof(char));
    if (!state) {
        return NULL;
    }
    

    const int faceToStringMap[6] = {
        FACE_IDX_TOP,
        FACE_IDX_FRONT,   
        FACE_IDX_RIGHT,   
        FACE_IDX_BACK,         
        FACE_IDX_LEFT,
        FACE_IDX_BOTTOM
    };
    
    int stringIndex = 0;
    for (int stringFace = 0; stringFace < 6; stringFace++) {
        int faceIndex = faceToStringMap[stringFace];
        
        for (int pos = 0; pos < 9; pos++) {
            RGBColor color = cubeColors[faceIndex][pos];
            state[stringIndex] = rgb_to_char(color);
            stringIndex++;
        }
    }
    
    state[54] = '\0';
    
    return state;
}

RGBColor* scene_get_cube_colors(Scene* scene) {
    return (RGBColor*)scene->cubeColors;
}

/* Операции с вращением */
bool scene_is_rotating(Scene* scene) {
    return scene->isRotating;
}

// Начать анимацию вращения
void scene_start_rotation(Scene* scene, FaceIndex face, RotationDirection direction, int repetitions) {
    if (scene->isRotating) {
        return; // Не начинать анимацию вращения если одна уже в процессе
    }
    
    scene->isRotating = true;
    scene->rotationAngle = 0.0f;
    scene->rotationTarget = 90.0f * repetitions;
    scene->rotatingFace = face;
    scene->rotationRepetitions = repetitions;
    
    // Получаем слой кубов и направление вращание для каждой комбинации вращения и face
    switch (face) {
        case FACE_IDX_TOP:
            scene->rotationAxis = 'y';
            scene->rotatingLayer = 2;
            scene->rotationDirection = direction;
            break;
        case FACE_IDX_BOTTOM:
            scene->rotationAxis = 'y';
            scene->rotatingLayer = 0;
            scene->rotationDirection = -direction;
            break;
        case FACE_IDX_RIGHT:
            scene->rotationAxis = 'x';
            scene->rotatingLayer = 2;
            scene->rotationDirection = direction; 
            break;
        case FACE_IDX_LEFT:
            scene->rotationAxis = 'x';
            scene->rotatingLayer = 0; 
            scene->rotationDirection = -direction;
            break;
        case FACE_IDX_FRONT:
            scene->rotationAxis = 'z';
            scene->rotatingLayer = 2; 
            scene->rotationDirection = direction; 
            break;
        case FACE_IDX_BACK:
            scene->rotationAxis = 'z';
            scene->rotatingLayer = 0;
            scene->rotationDirection = -direction; 
            break;
    }
}

// Повернуть цвета на face в направлении direction и соседние элементы к ним
void rotate_face_colors(RGBColor (*cubeColors)[9], FaceIndex face, RotationDirection direction) {
    RGBColor tempColors[6][9];
    for (int f = 0; f < 6; f++) {
        for (int p = 0; p < 9; p++) {
            tempColors[f][p] = cubeColors[f][p];
        }
    }

    if (face == FACE_IDX_TOP || face == FACE_IDX_BACK || face == FACE_IDX_RIGHT) direction = -direction;

    // Поворот цветов на лицевой стороне
    if (direction == ROTATE_CLOCKWISE) {  
        cubeColors[face][0] = tempColors[face][6];
        cubeColors[face][2] = tempColors[face][0];
        cubeColors[face][8] = tempColors[face][2];
        cubeColors[face][6] = tempColors[face][8];
        
        cubeColors[face][1] = tempColors[face][3];
        cubeColors[face][5] = tempColors[face][1];
        cubeColors[face][7] = tempColors[face][5];
        cubeColors[face][3] = tempColors[face][7];
    } else {       
        cubeColors[face][0] = tempColors[face][2];
        cubeColors[face][2] = tempColors[face][8];
        cubeColors[face][8] = tempColors[face][6];
        cubeColors[face][6] = tempColors[face][0];
        
        cubeColors[face][1] = tempColors[face][5];
        cubeColors[face][5] = tempColors[face][7];
        cubeColors[face][7] = tempColors[face][3];
        cubeColors[face][3] = tempColors[face][1];
    }
    
    if (face == FACE_IDX_TOP || face == FACE_IDX_BOTTOM || face == FACE_IDX_LEFT || face == FACE_IDX_RIGHT) direction = -direction;

    switch (face) {
        case FACE_IDX_TOP:
            if (direction == ROTATE_CLOCKWISE) {
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_RIGHT][2-i] = tempColors[FACE_IDX_BACK][i];
                }
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_BACK][2-i] = tempColors[FACE_IDX_LEFT][i];
                }
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_LEFT][2-i] = tempColors[FACE_IDX_FRONT][i];
                }
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_FRONT][2-i] = tempColors[FACE_IDX_RIGHT][i];
                }
            } else {
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_LEFT][2-i] = tempColors[FACE_IDX_BACK][i];
                }
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_BACK][2-i] = tempColors[FACE_IDX_RIGHT][i];
                }
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_RIGHT][2-i] = tempColors[FACE_IDX_FRONT][i];
                }
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_FRONT][2-i] = tempColors[FACE_IDX_LEFT][i];
                }
            }
            break;
        case FACE_IDX_BOTTOM:
            if (direction == ROTATE_CLOCKWISE) {
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_LEFT][2-i+6] = tempColors[FACE_IDX_BACK][6+i];
                }
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_BACK][2-i+6] = tempColors[FACE_IDX_RIGHT][6+i];
                }
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_RIGHT][2-i+6] = tempColors[FACE_IDX_FRONT][6+i];
                }
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_FRONT][2-i+6] = tempColors[FACE_IDX_LEFT][6+i];
                }
            } else {
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_RIGHT][2-i+6] = tempColors[FACE_IDX_BACK][6+i];
                }
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_BACK][2-i+6] = tempColors[FACE_IDX_LEFT][6+i];
                }
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_LEFT][2-i+6] = tempColors[FACE_IDX_FRONT][6+i];
                }
                for (int i = 0; i < 3; i++) {
                    cubeColors[FACE_IDX_FRONT][2-i+6] = tempColors[FACE_IDX_RIGHT][6+i];
                }
            }
            break;
        case FACE_IDX_FRONT:
            if (direction == ROTATE_CLOCKWISE) {
                cubeColors[FACE_IDX_RIGHT][8] = tempColors[FACE_IDX_TOP][2];
                cubeColors[FACE_IDX_RIGHT][5] = tempColors[FACE_IDX_TOP][1];
                cubeColors[FACE_IDX_RIGHT][2] = tempColors[FACE_IDX_TOP][0];
                
                cubeColors[FACE_IDX_BOTTOM][6] = tempColors[FACE_IDX_RIGHT][8];
                cubeColors[FACE_IDX_BOTTOM][7] = tempColors[FACE_IDX_RIGHT][5];
                cubeColors[FACE_IDX_BOTTOM][8] = tempColors[FACE_IDX_RIGHT][2];
                
                cubeColors[FACE_IDX_LEFT][6] = tempColors[FACE_IDX_BOTTOM][8];
                cubeColors[FACE_IDX_LEFT][3] = tempColors[FACE_IDX_BOTTOM][7];
                cubeColors[FACE_IDX_LEFT][0] = tempColors[FACE_IDX_BOTTOM][6];
                
                cubeColors[FACE_IDX_TOP][2] = tempColors[FACE_IDX_LEFT][0];
                cubeColors[FACE_IDX_TOP][1] = tempColors[FACE_IDX_LEFT][3];
                cubeColors[FACE_IDX_TOP][0] = tempColors[FACE_IDX_LEFT][6];
            } else {
                cubeColors[FACE_IDX_LEFT][0] = tempColors[FACE_IDX_TOP][2];
                cubeColors[FACE_IDX_LEFT][3] = tempColors[FACE_IDX_TOP][1];
                cubeColors[FACE_IDX_LEFT][6] = tempColors[FACE_IDX_TOP][0];
                
                cubeColors[FACE_IDX_BOTTOM][6] = tempColors[FACE_IDX_LEFT][0];
                cubeColors[FACE_IDX_BOTTOM][7] = tempColors[FACE_IDX_LEFT][3];
                cubeColors[FACE_IDX_BOTTOM][8] = tempColors[FACE_IDX_LEFT][6];
                
                cubeColors[FACE_IDX_RIGHT][2] = tempColors[FACE_IDX_BOTTOM][8];
                cubeColors[FACE_IDX_RIGHT][5] = tempColors[FACE_IDX_BOTTOM][7];
                cubeColors[FACE_IDX_RIGHT][8] = tempColors[FACE_IDX_BOTTOM][6];
                
                cubeColors[FACE_IDX_TOP][2] = tempColors[FACE_IDX_RIGHT][8];
                cubeColors[FACE_IDX_TOP][1] = tempColors[FACE_IDX_RIGHT][5];
                cubeColors[FACE_IDX_TOP][0] = tempColors[FACE_IDX_RIGHT][2];
            }
            break;
        case FACE_IDX_BACK:
            if (direction == ROTATE_CLOCKWISE) {                
                cubeColors[FACE_IDX_LEFT][2] = tempColors[FACE_IDX_TOP][8];
                cubeColors[FACE_IDX_LEFT][5] = tempColors[FACE_IDX_TOP][7];
                cubeColors[FACE_IDX_LEFT][8] = tempColors[FACE_IDX_TOP][6];

                cubeColors[FACE_IDX_BOTTOM][0] = tempColors[FACE_IDX_LEFT][2];
                cubeColors[FACE_IDX_BOTTOM][1] = tempColors[FACE_IDX_LEFT][5];
                cubeColors[FACE_IDX_BOTTOM][2] = tempColors[FACE_IDX_LEFT][8];
                
                cubeColors[FACE_IDX_RIGHT][6] = tempColors[FACE_IDX_BOTTOM][0];
                cubeColors[FACE_IDX_RIGHT][3] = tempColors[FACE_IDX_BOTTOM][1];
                cubeColors[FACE_IDX_RIGHT][0] = tempColors[FACE_IDX_BOTTOM][2];
                
                cubeColors[FACE_IDX_TOP][6] = tempColors[FACE_IDX_RIGHT][0];
                cubeColors[FACE_IDX_TOP][7] = tempColors[FACE_IDX_RIGHT][3];
                cubeColors[FACE_IDX_TOP][8] = tempColors[FACE_IDX_RIGHT][6];
            } else {
                cubeColors[FACE_IDX_RIGHT][0] = tempColors[FACE_IDX_TOP][6];
                cubeColors[FACE_IDX_RIGHT][3] = tempColors[FACE_IDX_TOP][7];
                cubeColors[FACE_IDX_RIGHT][6] = tempColors[FACE_IDX_TOP][8];
                
                cubeColors[FACE_IDX_BOTTOM][2] = tempColors[FACE_IDX_RIGHT][0];
                cubeColors[FACE_IDX_BOTTOM][1] = tempColors[FACE_IDX_RIGHT][3];
                cubeColors[FACE_IDX_BOTTOM][0] = tempColors[FACE_IDX_RIGHT][6];
                
                cubeColors[FACE_IDX_LEFT][8] = tempColors[FACE_IDX_BOTTOM][2];
                cubeColors[FACE_IDX_LEFT][5] = tempColors[FACE_IDX_BOTTOM][1];
                cubeColors[FACE_IDX_LEFT][2] = tempColors[FACE_IDX_BOTTOM][0];
            
                cubeColors[FACE_IDX_TOP][8] = tempColors[FACE_IDX_LEFT][2];
                cubeColors[FACE_IDX_TOP][7] = tempColors[FACE_IDX_LEFT][5];
                cubeColors[FACE_IDX_TOP][6] = tempColors[FACE_IDX_LEFT][8];
            }
            break;
        case FACE_IDX_LEFT:
            if (direction == ROTATE_CLOCKWISE) {
                cubeColors[FACE_IDX_FRONT][0] = tempColors[FACE_IDX_TOP][6];
                cubeColors[FACE_IDX_FRONT][3] = tempColors[FACE_IDX_TOP][3];
                cubeColors[FACE_IDX_FRONT][6] = tempColors[FACE_IDX_TOP][0];
                
                cubeColors[FACE_IDX_BOTTOM][0] = tempColors[FACE_IDX_FRONT][6];
                cubeColors[FACE_IDX_BOTTOM][3] = tempColors[FACE_IDX_FRONT][3];
                cubeColors[FACE_IDX_BOTTOM][6] = tempColors[FACE_IDX_FRONT][0];
                
                cubeColors[FACE_IDX_BACK][2] = tempColors[FACE_IDX_BOTTOM][0];
                cubeColors[FACE_IDX_BACK][5] = tempColors[FACE_IDX_BOTTOM][3];
                cubeColors[FACE_IDX_BACK][8] = tempColors[FACE_IDX_BOTTOM][6];
                
                cubeColors[FACE_IDX_TOP][0] = tempColors[FACE_IDX_BACK][2];
                cubeColors[FACE_IDX_TOP][3] = tempColors[FACE_IDX_BACK][5];
                cubeColors[FACE_IDX_TOP][6] = tempColors[FACE_IDX_BACK][8];
            } else {
                cubeColors[FACE_IDX_BACK][8] = tempColors[FACE_IDX_TOP][6];
                cubeColors[FACE_IDX_BACK][5] = tempColors[FACE_IDX_TOP][3];
                cubeColors[FACE_IDX_BACK][2] = tempColors[FACE_IDX_TOP][0];
                
                cubeColors[FACE_IDX_BOTTOM][0] = tempColors[FACE_IDX_BACK][2];
                cubeColors[FACE_IDX_BOTTOM][3] = tempColors[FACE_IDX_BACK][5];
                cubeColors[FACE_IDX_BOTTOM][6] = tempColors[FACE_IDX_BACK][8];
                
                cubeColors[FACE_IDX_FRONT][0] = tempColors[FACE_IDX_BOTTOM][6];
                cubeColors[FACE_IDX_FRONT][3] = tempColors[FACE_IDX_BOTTOM][3];
                cubeColors[FACE_IDX_FRONT][6] = tempColors[FACE_IDX_BOTTOM][0];
                
                cubeColors[FACE_IDX_TOP][0] = tempColors[FACE_IDX_FRONT][6];
                cubeColors[FACE_IDX_TOP][3] = tempColors[FACE_IDX_FRONT][3];
                cubeColors[FACE_IDX_TOP][6] = tempColors[FACE_IDX_FRONT][0];
            }
            break;
        case FACE_IDX_RIGHT:
            if (direction == ROTATE_CLOCKWISE) {                
                cubeColors[FACE_IDX_BACK][6] = tempColors[FACE_IDX_TOP][8];
                cubeColors[FACE_IDX_BACK][3] = tempColors[FACE_IDX_TOP][5];
                cubeColors[FACE_IDX_BACK][0] = tempColors[FACE_IDX_TOP][2];
                
                cubeColors[FACE_IDX_BOTTOM][2] = tempColors[FACE_IDX_BACK][0];
                cubeColors[FACE_IDX_BOTTOM][5] = tempColors[FACE_IDX_BACK][3];
                cubeColors[FACE_IDX_BOTTOM][8] = tempColors[FACE_IDX_BACK][6];
                
                cubeColors[FACE_IDX_FRONT][2] = tempColors[FACE_IDX_BOTTOM][8];
                cubeColors[FACE_IDX_FRONT][5] = tempColors[FACE_IDX_BOTTOM][5];
                cubeColors[FACE_IDX_FRONT][8] = tempColors[FACE_IDX_BOTTOM][2];
                
                cubeColors[FACE_IDX_TOP][2] = tempColors[FACE_IDX_FRONT][8];
                cubeColors[FACE_IDX_TOP][5] = tempColors[FACE_IDX_FRONT][5];
                cubeColors[FACE_IDX_TOP][8] = tempColors[FACE_IDX_FRONT][2];

            } else {
                cubeColors[FACE_IDX_FRONT][2] = tempColors[FACE_IDX_TOP][8];
                cubeColors[FACE_IDX_FRONT][5] = tempColors[FACE_IDX_TOP][5];
                cubeColors[FACE_IDX_FRONT][8] = tempColors[FACE_IDX_TOP][2];
                
                cubeColors[FACE_IDX_BOTTOM][2] = tempColors[FACE_IDX_FRONT][8];
                cubeColors[FACE_IDX_BOTTOM][5] = tempColors[FACE_IDX_FRONT][5];
                cubeColors[FACE_IDX_BOTTOM][8] = tempColors[FACE_IDX_FRONT][2];
                
                cubeColors[FACE_IDX_BACK][6] = tempColors[FACE_IDX_BOTTOM][8];
                cubeColors[FACE_IDX_BACK][3] = tempColors[FACE_IDX_BOTTOM][5];
                cubeColors[FACE_IDX_BACK][0] = tempColors[FACE_IDX_BOTTOM][2];
                
                cubeColors[FACE_IDX_TOP][8] = tempColors[FACE_IDX_BACK][6];
                cubeColors[FACE_IDX_TOP][5] = tempColors[FACE_IDX_BACK][3];
                cubeColors[FACE_IDX_TOP][2] = tempColors[FACE_IDX_BACK][0];
            }
            break;
    }
}


// Move sequence management functions

void scene_init_move_queue(Scene* scene) {
    scene->moveQueue = NULL;
    scene->moveQueueSize = 0;
    scene->moveQueueCapacity = 0;
    scene->currentMoveIndex = 0;
    scene->processingSequence = false;
    scene->originalSpeedBeforeSequence = 1.0f;
    
    // Initialize browse mode
    scene->browseMode = false;
    scene->browseIndex = 0;
}

void scene_destroy_move_queue(Scene* scene) {
    if (scene->moveQueue) {
        // Освобождаем каждую строку хода
        for (int i = 0; i < scene->moveQueueSize; i++) {
            if (scene->moveQueue[i]) {
                free(scene->moveQueue[i]);
            }
        }
        free(scene->moveQueue);
        scene->moveQueue = NULL;
    }
    scene->moveQueueSize = 0;
    scene->moveQueueCapacity = 0;
    scene->currentMoveIndex = 0;
    scene->processingSequence = false;
    
    scene->browseMode = false;
    scene->browseIndex = 0;
}

void scene_add_move_to_queue(Scene* scene, const char* move) {
    if (!scene || !move) return;
    
    // Увеличиваем очередь если необходимо 
    if (scene->moveQueueSize >= scene->moveQueueCapacity) {
        int newCapacity = scene->moveQueueCapacity == 0 ? 16 : scene->moveQueueCapacity * 2;
        char** newQueue = (char**)realloc(scene->moveQueue, newCapacity * sizeof(char*));
        if (!newQueue) {
            fprintf(stderr, "Failed to expand move queue\n");
            return;
        }
        scene->moveQueue = newQueue;
        scene->moveQueueCapacity = newCapacity;
    }
    
    // Копируем строчку ходов
    size_t moveLen = strlen(move);
    scene->moveQueue[scene->moveQueueSize] = (char*)malloc((moveLen + 1) * sizeof(char));
    if (!scene->moveQueue[scene->moveQueueSize]) {
        fprintf(stderr, "Failed to allocate memory for move string\n");
        return;
    }
    strcpy(scene->moveQueue[scene->moveQueueSize], move);
    scene->moveQueueSize++;
}

// Функция чтобы извлечь direction и face из строчки хода
static bool parse_move_string(const char* moveStr, FaceIndex* face, RotationDirection* direction, int* repetitions) {
    if (!moveStr || strlen(moveStr) == 0) return false;
    
    *repetitions = 1;
    *direction = ROTATE_CLOCKWISE;
    
    char faceChar = moveStr[0];
    switch (faceChar) {
        case 'U': case 'u': *face = FACE_IDX_TOP; break;
        case 'D': case 'd': *face = FACE_IDX_BOTTOM; break;
        case 'F': case 'f': *face = FACE_IDX_FRONT; break;
        case 'B': case 'b': *face = FACE_IDX_BACK; break;
        case 'R': case 'r': *face = FACE_IDX_RIGHT; break;
        case 'L': case 'l': *face = FACE_IDX_LEFT; break;
        default: return false;
    }
    
    for (size_t i = 1; i < strlen(moveStr); i++) {
        char modifier = moveStr[i];
        if (modifier == '\'' || modifier == '\'') {
            *direction = ROTATE_COUNTERCLOCKWISE;
        } else if (modifier == '2') {
            *repetitions = 2;
        }
    }
    
    return true;
}

// Функция чтобы получить обратный ход ( для возврата в режиме по ходам)
static bool get_inverse_move(const char* moveStr, FaceIndex* face, RotationDirection* direction, int* repetitions) {
    if (!parse_move_string(moveStr, face, direction, repetitions)) {
        return false;
    }
    
    *direction = (*direction == ROTATE_CLOCKWISE) ? ROTATE_COUNTERCLOCKWISE : ROTATE_CLOCKWISE;
    
    return true;
}

// Обрабюотка очереди ходов
void scene_process_move_queue(Scene* scene) {
    if (!scene || !scene->processingSequence || scene->currentMoveIndex >= scene->moveQueueSize) {
        return;
    }
    
    // Если сей1час аниманиця поворота не играет, начинаем поворот следующего 
    if (!scene->isRotating) {
        const char* moveStr = scene->moveQueue[scene->currentMoveIndex];
        FaceIndex face;
        RotationDirection direction;
        int repetitions;
        
        if (parse_move_string(moveStr, &face, &direction, &repetitions)) {
            printf("Executing move %d/%d: %s\n", 
                   scene->currentMoveIndex + 1, scene->moveQueueSize, moveStr);
            
            // Запускаем анимацию
            scene_start_rotation(scene, face, direction, repetitions);
            scene->currentMoveIndex++;
            
            // Если ходы кончились очищаем очередь и сбрасываем скорость
            if (scene->currentMoveIndex >= scene->moveQueueSize) {
                printf("Move sequence completed! Restoring speed to %.1fx\n", scene->originalSpeedBeforeSequence);
                scene_set_speed_multiplier(scene, scene->originalSpeedBeforeSequence);
                scene->processingSequence = false;
                scene->currentMoveIndex = 0;
                scene->moveQueueSize = 0; 
            }
        } else {
            fprintf(stderr, "Invalid move string: %s\n", moveStr);
            scene->currentMoveIndex++;
        }
    }
}

bool scene_is_processing_sequence(Scene* scene) {
    return scene ? scene->processingSequence : false;
}

// Функция чтобы сразу проиграть всю цепочку ходов
void apply_move_sequence(Scene* scene, char** moveSequence) {
    
    if (scene->processingSequence || scene->isRotating) {
        printf("Cannot start new move sequence: one is already in progress\n");
        return;
    }
    
    scene->originalSpeedBeforeSequence = scene->speedMultiplier;
    
    scene_destroy_move_queue(scene);
    scene_init_move_queue(scene);
    
    int moveCount = 0;
    while (moveSequence[moveCount] != NULL) {
        moveCount++;
    }
    
    if (moveCount == 0) {
        printf("Empty move sequence provided\n");
        scene_set_speed_multiplier(scene, scene->originalSpeedBeforeSequence);
        return;
    }
    
    printf("Starting move sequence with %d moves at %.1fx speed: ", moveCount, scene->speedMultiplier);
    for (int i = 0; i < moveCount; i++) {
        scene_add_move_to_queue(scene, moveSequence[i]);
        printf("%s ", moveSequence[i]);
    }
    printf("\n");
    
    scene->processingSequence = true;
    scene->currentMoveIndex = 0;
}


// Browse mode functions

void scene_enter_browse_mode(Scene* scene) {
    if (!scene || scene->moveQueueSize == 0) {
        printf("Cannot enter browse mode: no moves in queue\n");
        return;
    }
    
    scene->processingSequence = false;
    
    scene->browseMode = true;
    scene->browseIndex = 0;
    
    printf("Entered browse mode with %d moves. Use arrow keys to navigate, C to exit.\n", scene->moveQueueSize);
    printf("Ready to apply move [%d/%d]: %s\n", scene->browseIndex + 1, scene->moveQueueSize, 
           scene->moveQueue[scene->browseIndex]);
}

void scene_exit_browse_mode(Scene* scene) {
    if (!scene || !scene->browseMode) {
        return;
    }
    
    printf("Exiting browse mode\n");
    scene->browseMode = false;
    scene->browseIndex = 0;
}

void scene_browse_next(Scene* scene) {
    if (!scene || !scene->browseMode || scene->moveQueueSize == 0) {
        return;
    }
    
    if (scene->browseIndex >= scene->moveQueueSize) {
        printf("Already at the end of sequence\n");
        return;
    }
    
    const char* currentMoveStr = scene->moveQueue[scene->browseIndex];
    FaceIndex face;
    RotationDirection direction;
    int repetitions;
    
    if (parse_move_string(currentMoveStr, &face, &direction, &repetitions)) {
        printf("Applying move [%d/%d]: %s\n", 
               scene->browseIndex + 1, scene->moveQueueSize, currentMoveStr);
        
        scene_start_rotation(scene, face, direction, repetitions);
    }
    
    scene->browseIndex++;
    
    if (scene->browseIndex < scene->moveQueueSize) {
        printf("Now at move [%d/%d]: %s\n", scene->browseIndex + 1, scene->moveQueueSize, 
               scene->moveQueue[scene->browseIndex]);
    } else {
        printf("Reached the end of sequence (all moves applied)\n");
    }
}

void scene_browse_previous(Scene* scene) {
    if (!scene || !scene->browseMode || scene->moveQueueSize == 0) {
        return;
    }
    
    if (scene->browseIndex <= 0) {
        printf("Already at the beginning of sequence - no moves to undo\n");
        return;
    }
    
    scene->browseIndex--;
    
    const char* moveToUndo = scene->moveQueue[scene->browseIndex];
    FaceIndex face;
    RotationDirection direction;
    int repetitions;
    
    if (get_inverse_move(moveToUndo, &face, &direction, &repetitions)) {
        printf("Undoing move [%d/%d]: %s (applying inverse)\n", 
               scene->browseIndex + 1, scene->moveQueueSize, moveToUndo);
        
        scene_start_rotation(scene, face, direction, repetitions);
    }
    
    printf("Now at move [%d/%d]: %s\n", scene->browseIndex + 1, scene->moveQueueSize, 
           scene->moveQueue[scene->browseIndex]);
}

bool scene_is_in_browse_mode(Scene* scene) {
    return scene ? scene->browseMode : false;
}

// Color mode functions

static void move_camera_to_color_face(Window* window, FaceIndex face) {
    printf("Moving camera to face %d\n", face);
    switch (face) {
        case FACE_IDX_TOP:
            camera_move_to(window_get_camera(window), 90.0f, 1.0f, 1.0f);
            break;
        case FACE_IDX_FRONT:
            camera_move_to(window_get_camera(window), 90.0f, 90.0f, 1.0f);
            break;
        case FACE_IDX_RIGHT:
            camera_move_to(window_get_camera(window), 0.0f, 90.0f, 1.0f);
            break;
        case FACE_IDX_BACK:
            camera_move_to(window_get_camera(window), -90.0f, 90.0f, 1.0f);
            break;
        case FACE_IDX_LEFT:
            camera_move_to(window_get_camera(window), -180.0f, 90.0f, 1.0f);
            break;
        case FACE_IDX_BOTTOM:
            camera_move_to(window_get_camera(window), -180.0f, 179.0f, 1.0f);
            break;
    }
}

static int get_cell_index_on_face(FaceIndex face, int cellIndex) {
    int top_cells[] = {6, 7, 8, 3, 4, 5, 0, 1, 2};
    int side_cells[] = {2, 1, 0, 5, 4, 3, 8, 7, 6};
    int bottom_cells[] = {0, 3, 6, 1, 4, 7, 2, 5, 8};
    switch (face) {
        case FACE_IDX_TOP:
            return top_cells[cellIndex]; 
        case FACE_IDX_FRONT:
            return cellIndex;
        case FACE_IDX_RIGHT:
            return side_cells[cellIndex];
        case FACE_IDX_BACK:
            return cellIndex;
        case FACE_IDX_LEFT:
            return side_cells[cellIndex];
        case FACE_IDX_BOTTOM:
            return bottom_cells[cellIndex];
    }
}

bool scene_is_in_color_mode(Scene* scene) {
    return scene ? scene->colorMode : false;
}

void scene_enter_color_mode(Scene* scene, Window* window) {

    scene_set_cube_state_from_string(scene, "NNNNWNNNNNNNNRNNNNNNNNBNNNNNNNNONNNNNNNNGNNNNNNNNYNNNN");

    scene->colorMode = true;
    scene->colorFace = FACE_IDX_TOP;
    scene->cellIndex = 0;

    move_camera_to_color_face(window, scene->colorFace);
}

void scene_next_color_face(Scene* scene, Window* window) {
    if (!scene || !scene->colorMode) {
        return;
    }

    if (window->camera.isMoving) {
        return;
    }

    scene->cellIndex = 0;
    scene->colorFace = (scene->colorFace + 1) % 6;
    move_camera_to_color_face(window, scene->colorFace);
}

void scene_previous_color_face(Scene* scene, Window* window) {
    if (!scene || !scene->colorMode) {
        return;
    }

    if (window->camera.isMoving) {
        return;
    }

    scene->cellIndex = 0;
    scene->colorFace = (scene->colorFace - 1 + 6) % 6;
    move_camera_to_color_face(window, scene->colorFace);
}

void scene_exit_color_mode(Scene* scene, Window* window) {
    if (!scene || !scene->colorMode) {
        return;
    }
    scene->colorMode = false;
}

void scene_set_color_for_current_cell(Scene* scene, Window* window, char color) {
    if (!scene || !scene->colorMode) {
        return;
    }

    int index = get_cell_index_on_face(scene->colorFace, scene->cellIndex);
    scene->cubeColors[scene->colorFace][index] = get_rgb_from_cube_color(color);
    scene->cellIndex==3? scene->cellIndex=5 : scene->cellIndex == 8? scene->cellIndex=0 : scene->cellIndex++;
    for (int i = 0; i < scene->numCubes; i++) {
        mesh_destroy(&scene->cubes[i]);
    }
    create_textured_rubiks_cube_mesh(scene);
}

// Animation speed control functions

void scene_set_speed_multiplier(Scene* scene, float multiplier) {
    if (scene && multiplier > 0.0f) {
        scene->speedMultiplier = multiplier;
        printf("Animation speed set to %.1fx\n", multiplier);
    }
}

float scene_get_speed_multiplier(Scene* scene) {
    return scene ? scene->speedMultiplier : 1.0f;
}


./src/scene/scene.h:

#ifndef SCENE_H
#define SCENE_H

#include <stdbool.h>
#include "../renderer/shader.h"
#include "../renderer/mesh.h"
#include "../math/mat4.h"
#include "../types.h"
#include "../core/window.h"
// Color mapping for Rubik's cube faces
typedef enum {
    CUBE_COLOR_WHITE = 'W',   // Top face (U)
    CUBE_COLOR_YELLOW = 'Y',  // Bottom face (D)
    CUBE_COLOR_RED = 'R',     // Front face (F)
    CUBE_COLOR_ORANGE = 'O',  // Back face (B)
    CUBE_COLOR_BLUE = 'B',    // Right face (R)
    CUBE_COLOR_GREEN = 'G'    // Left face (L)
} CubeColor;

// Face indices for a Rubik's cube
typedef enum {
    FACE_IDX_TOP = 0,    // U - White
    FACE_IDX_FRONT = 1,  // F - Red
    FACE_IDX_RIGHT = 2,  // R - Blue 
    FACE_IDX_BACK = 3,   // B - Orange
    FACE_IDX_LEFT = 4,   // L - Green
    FACE_IDX_BOTTOM = 5  // D - Yellow
} FaceIndex;

// Rotation direction
typedef enum {
    ROTATE_CLOCKWISE = 1,
    ROTATE_COUNTERCLOCKWISE = -1,
    ROTATE_180 = 2
} RotationDirection;

struct Scene {
    Shader shader;
    
    Mesh* cubes;
    int numCubes;
    float positions[27][3]; // Координаты кубов
    RGBColor cubeColors[6][9]; // Цвета на гранях
    
    // Анимация вращения
    bool isRotating;
    float rotationAngle;
    float rotationTarget;
    FaceIndex rotatingFace;
    RotationDirection rotationDirection;
    int rotatingLayer;     // 0, 1, 2
    char rotationAxis;     // 'x', 'y', or 'z'
    int rotationRepetitions; 
    float speedMultiplier;   
    
    // Последовательность ходов
    char** moveQueue;      // Массив ходов
    int moveQueueSize;     // Число ходов в очереди
    int moveQueueCapacity; // Максимальная вместимость 
    int currentMoveIndex;  // Индекс текущего хода
    bool processingSequence;
    float originalSpeedBeforeSequence;
    
    // Browse mode 
    bool browseMode; 
    int browseIndex;

    bool colorMode;
    int colorFace;  // Текущая грань
    int cellIndex;  // Текущая ячейка
};

void scene_update(Scene* scene, Window* window, float deltaTime);
void scene_render(Scene* scene, Window* window);
void scene_destroy(Scene* scene);

bool scene_init_rubiks(Scene* scene);

bool scene_set_cube_state_from_string(Scene* scene, const char* state);


char* scene_get_cube_state_as_string(RGBColor (*cubeColors)[9]);
RGBColor* scene_get_cube_colors(Scene* scene);
void rotate_face_colors(RGBColor (*cubeColors)[9], FaceIndex face, RotationDirection direction);


void scene_start_rotation(Scene* scene, FaceIndex face, RotationDirection direction, int repetitions);

bool scene_is_rotating(Scene* scene);

void apply_move_sequence(Scene* scene, char** moveSequence);

// Последовательность ходов
void scene_init_move_queue(Scene* scene);
void scene_destroy_move_queue(Scene* scene);
void scene_add_move_to_queue(Scene* scene, const char* move);
void scene_process_move_queue(Scene* scene);
bool scene_is_processing_sequence(Scene* scene);

// Browse mode 
void scene_enter_browse_mode(Scene* scene);
void scene_exit_browse_mode(Scene* scene);
void scene_browse_next(Scene* scene);
void scene_browse_previous(Scene* scene);
bool scene_is_in_browse_mode(Scene* scene);

// Раскраска
void scene_enter_color_mode(Scene* scene, Window* window);
void scene_exit_color_mode(Scene* scene, Window* window);
bool scene_is_in_color_mode(Scene* scene);
void scene_next_color_face(Scene* scene, Window* window);
void scene_previous_color_face(Scene* scene, Window* window);
void scene_set_color_for_current_cell(Scene* scene, Window* window, char color);

// Animation speed control
void scene_set_speed_multiplier(Scene* scene, float multiplier);
float scene_get_speed_multiplier(Scene* scene);

#endif /* SCENE_H */

./src/solver/cube_solver.c:

#include "cube_solver.h"
#include "oll.h"
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>

static int index_array(int value, int* array){
    for (int k = 0; k < 4; ++k) {
        if (array[k] == value) {
            return k;
        }
    }
    return -1;
}

// Сравнение цветов с погрешностью
static bool colors_equal(RGBColor a, RGBColor b) {
    const float tolerance = 0.1f;
    return fabs(a.r - b.r) < tolerance && 
           fabs(a.g - b.g) < tolerance && 
           fabs(a.b - b.b) < tolerance;
}

static bool bottom_equal(int* array1, int* array2) {
    for (int i = 0; i < 9; i++) {
        if (array1[i] != array2[i]) {
            return false;
        }
    }
    return true;
}

static bool sides_equal(int (*array1)[3], int (*array2)[3]) {
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 3; j++) {
            if (array1[i][j] != array2[i][j]) {
                return false;
            }
        }
    }
    return true;
}

// Цвет центарльной ячейки на  грани
static RGBColor get_center_color(const RGBColor (*cubeColors)[9], FaceIndex face) {
    return cubeColors[face][4];
}

static RGBColor get_color(const RGBColor (*cubeColors)[9], FaceIndex face, int position) {
    return cubeColors[face][position];
}

static bool position_matches_center(const RGBColor (*cubeColors)[9], FaceIndex face, int position) {
    RGBColor center = get_center_color(cubeColors, face);
    return colors_equal(cubeColors[face][position], center);
}

void move_sequence_init(MoveSequence* sequence) {
    sequence->moves = NULL;
    sequence->count = 0;
    sequence->capacity = 0;
}

void move_sequence_add(MoveSequence* sequence, Move move, RGBColor (*cubeColors)[9]) {

    apply_move_to_cube_colors(cubeColors, move);

    if (sequence->count >= sequence->capacity) {
        sequence->capacity = sequence->capacity == 0 ? 16 : sequence->capacity * 2;
        sequence->moves = realloc(sequence->moves, sequence->capacity * sizeof(Move));
    }
    sequence->moves[sequence->count++] = move;
}

void move_sequence_destroy(MoveSequence* sequence) {
    if (sequence->moves) {
        free(sequence->moves);
        sequence->moves = NULL;
    }
    sequence->count = 0;
    sequence->capacity = 0;
}

void move_sequence_print(const MoveSequence* sequence) {
    printf("Solution (%d moves): ", sequence->count);
    for (int i = 0; i < sequence->count; i++) {
        printf("%s ", move_to_string(sequence->moves[i]));
    }
    printf("\n");
}

const char* move_to_string(Move move) {
    switch (move) {
        case MOVE_U: return "U";
        case MOVE_U_PRIME: return "U'";
        case MOVE_U2: return "U2";
        case MOVE_D: return "D";
        case MOVE_D_PRIME: return "D'";
        case MOVE_D2: return "D2";
        case MOVE_F: return "F";
        case MOVE_F_PRIME: return "F'";
        case MOVE_F2: return "F2";
        case MOVE_B: return "B";
        case MOVE_B_PRIME: return "B'";
        case MOVE_B2: return "B2";
        case MOVE_R: return "R";
        case MOVE_R_PRIME: return "R'";
        case MOVE_R2: return "R2";
        case MOVE_L: return "L";
        case MOVE_L_PRIME: return "L'";
        case MOVE_L2: return "L2";
        default: return "?";
    }
}

FaceIndex move_to_face(Move move) {
    switch (move) {
        case MOVE_U:
        case MOVE_U_PRIME:
        case MOVE_U2:
            return FACE_IDX_TOP;
        case MOVE_D:
        case MOVE_D_PRIME:
        case MOVE_D2:
            return FACE_IDX_BOTTOM;
        case MOVE_F:
        case MOVE_F_PRIME:
        case MOVE_F2:
            return FACE_IDX_FRONT;
        case MOVE_B:
        case MOVE_B_PRIME:
        case MOVE_B2:
            return FACE_IDX_BACK;
        case MOVE_R:
        case MOVE_R_PRIME:
        case MOVE_R2:
            return FACE_IDX_RIGHT;
        case MOVE_L:
        case MOVE_L_PRIME:
        case MOVE_L2:
            return FACE_IDX_LEFT;
        default:
            return FACE_IDX_TOP; // fallback
    }
}

RotationDirection move_to_direction(Move move) {
    switch (move) {
        case MOVE_U:
        case MOVE_D:
        case MOVE_F:
        case MOVE_B:
        case MOVE_R:
        case MOVE_L:
            return ROTATE_CLOCKWISE;
        case MOVE_U_PRIME:
        case MOVE_D_PRIME:
        case MOVE_F_PRIME:
        case MOVE_B_PRIME:
        case MOVE_R_PRIME:
        case MOVE_L_PRIME:
            return ROTATE_COUNTERCLOCKWISE;
        case MOVE_U2:
        case MOVE_D2:
        case MOVE_F2:
        case MOVE_B2:
        case MOVE_R2:
        case MOVE_L2:
            return ROTATE_180;
        default:
            return ROTATE_CLOCKWISE; 
    }
}

Move get_move_from_face_and_direction(FaceIndex face, RotationDirection direction) {
    switch (face) {
        case FACE_IDX_TOP:
            return direction == ROTATE_CLOCKWISE ? MOVE_U : direction == ROTATE_COUNTERCLOCKWISE ? MOVE_U_PRIME : MOVE_U2;
        case FACE_IDX_BOTTOM:
            return direction == ROTATE_CLOCKWISE ? MOVE_D : direction == ROTATE_COUNTERCLOCKWISE ? MOVE_D_PRIME : MOVE_D2;
        case FACE_IDX_FRONT:
            return direction == ROTATE_CLOCKWISE ? MOVE_F : direction == ROTATE_COUNTERCLOCKWISE ? MOVE_F_PRIME : MOVE_F2;
        case FACE_IDX_BACK:
            return direction == ROTATE_CLOCKWISE ? MOVE_B : direction == ROTATE_COUNTERCLOCKWISE ? MOVE_B_PRIME : MOVE_B2;
        case FACE_IDX_RIGHT:
            return direction == ROTATE_CLOCKWISE ? MOVE_R : direction == ROTATE_COUNTERCLOCKWISE ? MOVE_R_PRIME : MOVE_R2;
        case FACE_IDX_LEFT:
            return direction == ROTATE_CLOCKWISE ? MOVE_L : direction == ROTATE_COUNTERCLOCKWISE ? MOVE_L_PRIME : MOVE_L2;
        default:
            return MOVE_U; // fallback
    }
}

void apply_move_to_cube_colors(RGBColor (*cubeColors)[9], Move move) {
    FaceIndex face = move_to_face(move);

    RotationDirection direction = move_to_direction(move);
    if ((face == FACE_IDX_BOTTOM || face == FACE_IDX_BACK || face == FACE_IDX_LEFT) && direction != ROTATE_180){
        direction = -direction;
    }
    if (direction == ROTATE_180){
        direction = ROTATE_CLOCKWISE;
        rotate_face_colors(cubeColors, face, direction);
        rotate_face_colors(cubeColors, face, direction);
    }
    else {
        rotate_face_colors(cubeColors, face, direction);
    }
}

void copy_cube_state(const RGBColor (*source)[9], RGBColor (*dest)[9]) {
    for (int face = 0; face < 6; face++) {
        for (int pos = 0; pos < 9; pos++) {
            dest[face][pos] = source[face][pos];
        }
    }
}

bool is_cube_solved(const RGBColor (*cubeColors)[9]) {
    for (FaceIndex face = 0; face < 6; face++) {
        RGBColor center = get_center_color(cubeColors, face);
        for (int pos = 0; pos < 9; pos++) {
            if (!colors_equal(cubeColors[face][pos], center)) {
                return false;
            }
        }
    }
    return true;
}

static bool find_edge_piece(const RGBColor (*cubeColors)[9], RGBColor color1, RGBColor color2,
                            FaceIndex* face1, int* pos1, FaceIndex* face2, int* pos2) {
    static const struct {
        FaceIndex face1, pos1, face2, pos2;
    } edge_map[] = {
        {FACE_IDX_TOP, 1, FACE_IDX_FRONT, 1},
        {FACE_IDX_TOP, 3, FACE_IDX_LEFT, 1},
        {FACE_IDX_TOP, 5, FACE_IDX_RIGHT, 1},
        {FACE_IDX_TOP, 7, FACE_IDX_BACK, 1},

        {FACE_IDX_BOTTOM, 1, FACE_IDX_BACK, 7},
        {FACE_IDX_BOTTOM, 3, FACE_IDX_LEFT, 7},
        {FACE_IDX_BOTTOM, 5, FACE_IDX_RIGHT, 7},
        {FACE_IDX_BOTTOM, 7, FACE_IDX_FRONT, 7},

        { FACE_IDX_FRONT, 3, FACE_IDX_LEFT, 3},
        { FACE_IDX_FRONT, 5, FACE_IDX_RIGHT, 5},
        { FACE_IDX_BACK, 5, FACE_IDX_LEFT, 5},
        { FACE_IDX_BACK, 3, FACE_IDX_RIGHT, 3},
    };

    const int EDGE_COUNT = sizeof(edge_map) / sizeof(edge_map[0]);

    for (int i = 0; i < EDGE_COUNT; ++i) {
        FaceIndex f1 = edge_map[i].face1;
        int p1 = edge_map[i].pos1;
        FaceIndex f2 = edge_map[i].face2;
        int p2 = edge_map[i].pos2;

        RGBColor c1 = cubeColors[f1][p1];
        RGBColor c2 = cubeColors[f2][p2];

        if ((colors_equal(c1, color1) && colors_equal(c2, color2))) {
            *face1 = f1; *pos1 = p1;
            *face2 = f2; *pos2 = p2;
            return true;
        } else if ((colors_equal(c1, color2) && colors_equal(c2, color1))) {
            *face1 = f2; *pos1 = p2;
            *face2 = f1; *pos2 = p1;
            return true;
        }
    }

    return false;
}

static bool find_corner_piece(const RGBColor (*cubeColors)[9], RGBColor color1, RGBColor color2, RGBColor color3,
                              FaceIndex* face1, int* pos1, FaceIndex* face2, int* pos2, FaceIndex* face3, int* pos3) {
    static const struct {
        FaceIndex face1, pos1, face2, pos2, face3, pos3;
    } corner_map[] = {
        {FACE_IDX_TOP, 0, FACE_IDX_FRONT, 0, FACE_IDX_LEFT, 0},
        {FACE_IDX_TOP, 2, FACE_IDX_RIGHT, 2, FACE_IDX_FRONT, 2},
        {FACE_IDX_TOP, 6, FACE_IDX_LEFT, 2, FACE_IDX_BACK, 2},
        {FACE_IDX_TOP, 8, FACE_IDX_BACK, 0, FACE_IDX_RIGHT, 0},

        {FACE_IDX_BOTTOM, 0, FACE_IDX_BACK, 8, FACE_IDX_LEFT, 8},
        {FACE_IDX_BOTTOM, 2, FACE_IDX_RIGHT, 6, FACE_IDX_BACK, 6},
        {FACE_IDX_BOTTOM, 6, FACE_IDX_LEFT, 6, FACE_IDX_FRONT, 6},
        {FACE_IDX_BOTTOM, 8, FACE_IDX_FRONT, 8, FACE_IDX_RIGHT, 8},
    };

    const int CORNER_COUNT = sizeof(corner_map) / sizeof(corner_map[0]);

    for (int i = 0; i < CORNER_COUNT; ++i) {
        FaceIndex f1 = corner_map[i].face1;
        int p1 = corner_map[i].pos1;
        FaceIndex f2 = corner_map[i].face2;
        int p2 = corner_map[i].pos2;
        FaceIndex f3 = corner_map[i].face3;
        int p3 = corner_map[i].pos3;    
        
        RGBColor c1 = cubeColors[f1][p1];
        RGBColor c2 = cubeColors[f2][p2];
        RGBColor c3 = cubeColors[f3][p3];

        if (colors_equal(c1, color1) && colors_equal(c2, color2) && colors_equal(c3, color3)) {
            *face1 = f1; *pos1 = p1;    
            *face2 = f2; *pos2 = p2;
            *face3 = f3; *pos3 = p3;
            return true;
        } else if (colors_equal(c1, color1) && colors_equal(c2, color3) && colors_equal(c3, color2)) {
            *face1 = f1; *pos1 = p1;
            *face2 = f3; *pos2 = p3;
            *face3 = f2; *pos3 = p2;
            return true;
        } else if (colors_equal(c1, color2) && colors_equal(c2, color1) && colors_equal(c3, color3)) {
            *face1 = f2; *pos1 = p2;
            *face2 = f1; *pos2 = p1;
            *face3 = f3; *pos3 = p3;
            return true;
        } else if (colors_equal(c1, color2) && colors_equal(c2, color3) && colors_equal(c3, color1)) {
            *face1 = f2; *pos1 = p2;
            *face2 = f3; *pos2 = p3;
            *face3 = f1; *pos3 = p1;
            return true;
        } else if (colors_equal(c1, color3) && colors_equal(c2, color1) && colors_equal(c3, color2)) {
            *face1 = f3; *pos1 = p3;
            *face2 = f1; *pos2 = p1;
            *face3 = f2; *pos3 = p2;
            return true;
        } else if (colors_equal(c1, color3) && colors_equal(c2, color2) && colors_equal(c3, color1)) {
            *face1 = f3; *pos1 = p3;
            *face2 = f2; *pos2 = p2;
            *face3 = f1; *pos3 = p1;
            return true;
        }
    }

    return false;
}

static void get_yellow_positions(const RGBColor (*cubeColors)[9], int* positions_bottom, int (*positions_sides)[3]) {
    RGBColor yellow = get_center_color(cubeColors, FACE_IDX_BOTTOM);
    RGBColor green = get_center_color(cubeColors, FACE_IDX_FRONT);
    RGBColor blue = get_center_color(cubeColors, FACE_IDX_RIGHT);
    RGBColor red = get_center_color(cubeColors, FACE_IDX_BACK);
    RGBColor orange = get_center_color(cubeColors, FACE_IDX_LEFT);
    for (int i = 0; i < 9; i++) {
        positions_bottom[i] = 0;
    }
    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 3; j++) {
            positions_sides[i][j] = 0;
        }
    }

    for (int i = 0; i < 9; i++) {
        if (colors_equal(cubeColors[FACE_IDX_BOTTOM][i], yellow)) {
            positions_bottom[i] = 1;
        } 
    }
    int temp = 0;
    temp = positions_bottom[1];
    positions_bottom[1] = positions_bottom[3];
    positions_bottom[3] = temp;

    temp = positions_bottom[2];
    positions_bottom[2] = positions_bottom[6];
    positions_bottom[6] = temp;

    temp = positions_bottom[5];
    positions_bottom[5] = positions_bottom[7];
    positions_bottom[7] = temp;

    for (int i = 6; i < 9; i++) {
        if (colors_equal(cubeColors[FACE_IDX_FRONT][i], yellow)) {
            positions_sides[1][i - 6] = 1;
        }
        if (colors_equal(cubeColors[FACE_IDX_RIGHT][i], yellow)) {
            positions_sides[2][8 - i] = 1;
        }
        if (colors_equal(cubeColors[FACE_IDX_BACK][i], yellow)) {
            positions_sides[3][i - 6] = 1;
        }
        if (colors_equal(cubeColors[FACE_IDX_LEFT][i], yellow)) {
            positions_sides[0][8 - i] = 1;
        }
    }
}

static void get_side_positions(const RGBColor (*cubeColors)[9], int (*positions_sides)[3]) {
    RGBColor green = get_center_color(cubeColors, FACE_IDX_LEFT);
    RGBColor blue = get_center_color(cubeColors, FACE_IDX_RIGHT);
    RGBColor red = get_center_color(cubeColors, FACE_IDX_FRONT);
    RGBColor orange = get_center_color(cubeColors, FACE_IDX_BACK);

    for (int i = 0; i < 4; i++) {
        for (int j = 0; j < 3; j++) {
            positions_sides[i][j] = 0;
        }
    }

    for (int face = 1; face < 5; face++) {
        for (int i = 6; i < 9; i++) {
            int id = i - 6;
            if (face == FACE_IDX_LEFT || face == FACE_IDX_RIGHT) {
                id = 8 - i;
            }

            if (colors_equal(cubeColors[face][i], red)) {
                positions_sides[face-1][id] = 1;
            }
            if (colors_equal(cubeColors[face][i], blue)) {
                positions_sides[face-1][id] = 2;
            }
            if (colors_equal(cubeColors[face][i], orange)) {
                positions_sides[face-1][id] = 3;
            }
            if (colors_equal(cubeColors[face][i], green)) {
                positions_sides[face-1][id] = 4;
            }
        }
    }
}

static void solve_white_cross(RGBColor (*cubeColors)[9], MoveSequence* solution) {
    printf("Solving white cross...\n");
    
    RGBColor white = get_center_color(cubeColors, FACE_IDX_TOP);
    
    /*
           [7]
        [3]   [5]
           [1]
        нижняя грань (вид спереди, передняя грань со стороны 7)
    */
    int bottom_target_positions[] = {7, 5, 1, 3};

    /*
           [1]
        [5]   [3]
           [7]
        верхняя грань (вид спереди, передняя грань со стороны 1)
    */
    int top_target_positions[] = {1, 5, 7, 3};

    /*
        T
        F R B L
        D    
    */
    FaceIndex adjacent_faces[] = {FACE_IDX_FRONT, FACE_IDX_RIGHT, FACE_IDX_BACK, FACE_IDX_LEFT};
    Move down_moves[] = {MOVE_D_PRIME, MOVE_D2, MOVE_D};
    
    for (int i = 0; i < 4; i++) {
        int target_pos = top_target_positions[i];
        FaceIndex adj_face = adjacent_faces[i];
        RGBColor target_color = get_center_color(cubeColors, adj_face);

        // Проверяем, если это ребро уже стоит на месте        
        if (colors_equal(cubeColors[FACE_IDX_TOP][target_pos], white) &&
            position_matches_center(cubeColors, adj_face, 1) &&
            colors_equal(cubeColors[adj_face][1], target_color)) {
            continue; 
        }

        // Находим ребро
        FaceIndex white_face, color_face;
        int white_pos, color_pos;
        Move return_move = -1;

        if (!find_edge_piece(cubeColors, white, target_color, &white_face, &white_pos, &color_face, &color_pos)) {
            printf("No edge piece found\n");
            return;
        }

        // Если белый цвет сверху, но не на своем месте, то опускаем его вниз и обновляем положение 
        if (white_face == FACE_IDX_TOP) {
            move_sequence_add(solution,
                get_move_from_face_and_direction(color_face, ROTATE_180),
                cubeColors);
            find_edge_piece(cubeColors, white, target_color, &white_face, &white_pos, &color_face, &color_pos);
        } 

        // Если белый цвет на одной из боковых граней, то
        else if (white_face != FACE_IDX_BOTTOM) {

            // Если белый цвет сверху на боковой грани, то поворачиваем эту грань чтобы следующим ходом опустить его вниз
            if (white_pos == 1) {
                move_sequence_add(solution, get_move_from_face_and_direction(white_face, ROTATE_CLOCKWISE), cubeColors);
                find_edge_piece(cubeColors, white, target_color, &white_face, &white_pos, &color_face, &color_pos);
            } 
            // Если снизу, то 
            else if (white_pos == 7) {
                // Чтобы не помешать другим граням, поворачиваем нижнюю грань на свое место
                int white_pos_index = index_array(white_face, (int*)adjacent_faces);
                int move_index = ((white_pos_index - i) + 4) % 4;
                if (move_index != 0)
                    move_sequence_add(solution, down_moves[move_index - 1], cubeColors);
                find_edge_piece(cubeColors, white, target_color, &white_face, &white_pos, &color_face, &color_pos);
                // И делаем поворот чтобы следующим ходом опустить его вниз
                move_sequence_add(solution, get_move_from_face_and_direction(white_face, ROTATE_COUNTERCLOCKWISE), cubeColors);
                find_edge_piece(cubeColors, white, target_color, &white_face, &white_pos, &color_face, &color_pos);
            }

            // Если цвет на боковой грани, то
            if ((color_pos == 5 || color_pos == 3) && color_face != adj_face) {
                // В зависимости от положения цвета, поворачиваем грань по часовой или против часовой стрелки
                RotationDirection direction = color_pos == 5 ? ROTATE_CLOCKWISE : ROTATE_COUNTERCLOCKWISE;
                // Если цвет на левой или правой грани, то поворачиваем в противоположную сторону
                if (color_face == FACE_IDX_LEFT || color_face == FACE_IDX_RIGHT) direction *= -1;
                // Если сверху деталь на своем месте, то запоминаем, что надо будет вернуть его на место 
                if (colors_equal(get_color(cubeColors, FACE_IDX_TOP, top_target_positions[index_array(color_face, (int*)adjacent_faces)]), white)) {
                    return_move = get_move_from_face_and_direction(color_face, -direction);
                }
                move_sequence_add(solution, get_move_from_face_and_direction(color_face, direction), cubeColors);
                find_edge_piece(cubeColors, white, target_color, &white_face, &white_pos, &color_face, &color_pos);
            }

            // Если цвет на своей грани, то поворачиваем ее на свое место
            if (color_face == adj_face) {
                RotationDirection direction = color_pos == 3 ? ROTATE_CLOCKWISE : ROTATE_COUNTERCLOCKWISE;
                if (color_face == FACE_IDX_LEFT || color_face == FACE_IDX_RIGHT) {
                    direction = -direction;
                }
                move_sequence_add(solution, get_move_from_face_and_direction(color_face, direction), cubeColors);
                continue;
            }
        }

        // Если белый цвет на нижней грани, то поворачиваем нижнюю грань на свое место и поднимаем деталь вверх
        int white_pos_index = index_array(white_pos, bottom_target_positions);
        int move_index = ((white_pos_index - i) + 4) % 4;
        if (move_index != 0)
            move_sequence_add(solution, down_moves[move_index - 1], cubeColors);

        // Если надо вернуть деталь на место, то делаем это
        if (return_move != -1) {
            move_sequence_add(solution, return_move, cubeColors);
        }

        // Поворачиваем грань на 180 градусов, чтобы поставить деталь на свое место
        move_sequence_add(solution, get_move_from_face_and_direction(adj_face, ROTATE_180), cubeColors);

    }
}

static void solve_F2L(RGBColor (*cubeColors)[9], MoveSequence* solution) {
    printf("Solving F2L...\n");

    int bottom_target_positions[] = {1, 3, 7, 5};
    Move down_moves[] = {MOVE_D_PRIME, MOVE_D2, MOVE_D};
    FaceIndex adjacent_faces[] = {FACE_IDX_FRONT, FACE_IDX_RIGHT, FACE_IDX_BACK, FACE_IDX_LEFT};

    RGBColor white = get_center_color(cubeColors, FACE_IDX_TOP);

    // Проверяем, если все угловые детали на своем месте
    for (int i = 0; i < 4; i++) {
        FaceIndex face = FACE_IDX_FRONT + i;
        int pos = 1;
        FaceIndex face2 = (face + 1) % 5 + 1;
        int pos2 = 1;

        RGBColor color1 = get_center_color(cubeColors, face);
        RGBColor color2 = get_center_color(cubeColors, face2);

        FaceIndex color_face, color_face2;
        int color_pos, color_pos2;

        find_edge_piece(cubeColors, color1, color2, &color_face, &color_pos, &color_face2, &color_pos2);

        if (!(color_face == face && color_face2 == face2)) {
            break;
        }

        FaceIndex white_face;
        int white_pos;

        find_corner_piece(cubeColors, color1, color2, white, &color_face, &color_pos, &color_face2, &color_pos2, &white_face, &white_pos);

        if (!(color_face == face && color_face2 == face2 && white_face == FACE_IDX_TOP)) {
            break;
        }        
    }
    
    for (int i = 0; i < 4; i++) {
        FaceIndex face = FACE_IDX_FRONT + i;
        int pos = 1;
        FaceIndex face2 = (face % 4) + 1;
        int pos2 = 1;
        FaceIndex face3 = (face2 % 4) + 1;
        FaceIndex face4 = (face3 % 4) + 1;

        RGBColor color1 = get_center_color(cubeColors, face);
        RGBColor color2 = get_center_color(cubeColors, face2);

        FaceIndex edge_color_face, edge_color_face2;
        int edge_color_pos, edge_color_pos2;

        find_edge_piece(cubeColors, color1, color2, &edge_color_face, &edge_color_pos, &edge_color_face2, &edge_color_pos2);

        FaceIndex corner_color_face, corner_color_face2, corner_white_face;
        int corner_color_pos, corner_color_pos2, corner_white_pos;

        find_corner_piece(cubeColors, color1, color2, white, &corner_color_face, &corner_color_pos, &corner_color_face2, &corner_color_pos2, &corner_white_face, &corner_white_pos);
        
        
        // stuck cases
        if((!(corner_color_face == face && corner_color_face2 == face2 || corner_color_face2 == face && corner_white_face == face2 || corner_color_face == face2 && corner_white_face == face) && 
            (corner_white_face == FACE_IDX_TOP || corner_color_face == FACE_IDX_TOP || corner_color_face2 == FACE_IDX_TOP)))    
        {   
            FaceIndex face_before = (corner_white_face == 1) ? 4 : corner_white_face - 1;
            FaceIndex face_before1 = (corner_color_face == 1) ? 4 : corner_color_face - 1;
            FaceIndex face_before2 = (corner_color_face2 == 1) ? 4 : corner_color_face2 - 1;

            RotationDirection rotation = ROTATE_CLOCKWISE;

            FaceIndex corner_white_face_to_rotate = corner_white_face;

            if (corner_white_face == FACE_IDX_TOP) {
                corner_white_face_to_rotate = corner_color_face;
                if (edge_color_face == face_before1 || edge_color_face2 == face_before1) {
                    rotation *= -1;
                }
            } else if (corner_color_face == FACE_IDX_TOP) {
                corner_white_face_to_rotate = corner_color_face2;
                if (edge_color_face == face_before2 || edge_color_face2 == face_before2) {
                    rotation *= -1;
                }
            } else if (corner_color_face2 == FACE_IDX_TOP) {
                corner_white_face_to_rotate = corner_white_face;
                if (edge_color_face == face_before || edge_color_face2 == face_before) {
                    rotation *= -1;
                }
            }
            move_sequence_add(solution, get_move_from_face_and_direction(corner_white_face_to_rotate, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, rotation), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(corner_white_face_to_rotate, ROTATE_COUNTERCLOCKWISE), cubeColors);

            find_corner_piece(cubeColors, color1, color2, white, &corner_color_face, &corner_color_pos, &corner_color_face2, &corner_color_pos2, &corner_white_face, &corner_white_pos);
            find_edge_piece(cubeColors, color1, color2, &edge_color_face, &edge_color_pos, &edge_color_face2, &edge_color_pos2);
        } 
        if ( 
            !((edge_color_face == face && edge_color_face2 == face2) || (edge_color_face == face2 && edge_color_face2 == face)) && 
            !(edge_color_face == FACE_IDX_BOTTOM || edge_color_face2 == FACE_IDX_BOTTOM))
        {
            RotationDirection rotation = ROTATE_CLOCKWISE;
            FaceIndex edge_color_face_to_rotate = edge_color_face;
            if (edge_color_face == FACE_IDX_FRONT || edge_color_face == FACE_IDX_BACK) {
                if (edge_color_pos == 5) rotation = ROTATE_CLOCKWISE;
                else rotation = ROTATE_COUNTERCLOCKWISE;
            } else if (edge_color_face == FACE_IDX_LEFT || edge_color_face == FACE_IDX_RIGHT) {
                if (edge_color_pos == 5) rotation = ROTATE_COUNTERCLOCKWISE;
                else rotation = ROTATE_CLOCKWISE;
            }
            for (int i = 0; i < 2; i++) {
                move_sequence_add(solution, get_move_from_face_and_direction(edge_color_face_to_rotate, rotation), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(edge_color_face_to_rotate, -rotation), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }
            find_corner_piece(cubeColors, color1, color2, white, &corner_color_face, &corner_color_pos, &corner_color_face2, &corner_color_pos2, &corner_white_face, &corner_white_pos);
            find_edge_piece(cubeColors, color1, color2, &edge_color_face, &edge_color_pos, &edge_color_face2, &edge_color_pos2);
        } 

        // printf("face1: %d, face2: %d\n", face, face2);


        FaceIndex face_after_corner_white_face = (corner_white_face == 4) ? 1 : corner_white_face + 1;

        FaceIndex face_before_corner_white_face = (corner_white_face == 1) ? 4 : corner_white_face - 1;

        FaceIndex face_on_the_other_side_of_white = (corner_white_face + 1) % 4 + 1;

        FaceIndex face_on_the_other_side_of_color = (corner_color_face + 1) % 4 + 1;
        FaceIndex face_on_the_other_side_of_color2 = (corner_color_face2 + 1) % 4 + 1;
        
        // Basic Inserts

        // F2L 1,2
        if (edge_color_face == corner_color_face && edge_color_face2 == corner_color_face2 && corner_white_face != FACE_IDX_BOTTOM) {
            int white_pos_index = index_array(corner_white_face, (int*)adjacent_faces);
            if (edge_color_face == FACE_IDX_BOTTOM) {
                printf("F2L 1\n");
                RotationDirection direction = ROTATE_CLOCKWISE;
                if (corner_white_face == face) {
                    move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                } else if (corner_white_face == face2) {
                    move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
                } else if (corner_white_face == face3) {
                    direction = ROTATE_180;
                }

                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, direction), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            }
            else 
            // F2L 2 work
            if (edge_color_face2 == FACE_IDX_BOTTOM) {
                printf("F2L 2\n");
                RotationDirection direction = ROTATE_COUNTERCLOCKWISE;
                if (corner_white_face == face) {
                    move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
                } else if (corner_white_face == face2) {
                    move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                } else if (corner_white_face == face4) {
                    direction = ROTATE_180;
                }
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, direction), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }
        }
        
        // F2L 3 work
        else if (edge_color_face2 == face_after_corner_white_face && edge_color_face == FACE_IDX_BOTTOM && corner_color_face2 == FACE_IDX_BOTTOM) {
            printf("F2L 3\n");
            if (corner_white_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
        }
        // F2L 4 work
        else if (edge_color_face == face_before_corner_white_face && edge_color_face2 == FACE_IDX_BOTTOM && corner_color_face == FACE_IDX_BOTTOM) {
            printf("F2L 4\n");
            if (corner_white_face == face2) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }

        // Reposition Edge
        
        // F2L 5 work
        else if (edge_color_face == face_on_the_other_side_of_white && edge_color_face2 == FACE_IDX_BOTTOM && corner_color_face2 == FACE_IDX_BOTTOM) {
            printf("F2L 5\n");
            if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face2) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }
    
        // F2L 6 work?
        else if (edge_color_face2 == face_on_the_other_side_of_white && edge_color_face == FACE_IDX_BOTTOM && corner_color_face == FACE_IDX_BOTTOM) {
            printf("F2L 6\n");
            if (corner_white_face == face2) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);

            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);

        }
    
        // F2L 7 work
        else if (edge_color_face == face_after_corner_white_face && edge_color_face2 == FACE_IDX_BOTTOM && corner_color_face2 == FACE_IDX_BOTTOM) {
            printf("F2L 7\n");
            if (corner_white_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            for (int i = 0; i < 2; i++) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }  
        }
    
        // F2L 8
        else if (edge_color_face2 == face_before_corner_white_face && edge_color_face == FACE_IDX_BOTTOM && corner_color_face == FACE_IDX_BOTTOM) {
            printf("F2L 8\n");
            if (corner_white_face == face2) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            for (int i = 0; i < 2; i++) {
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }
    
        // Reposition Edge and Flip Corner

        // F2L 9
        else if (edge_color_face2 == face_on_the_other_side_of_white && edge_color_face == FACE_IDX_BOTTOM && corner_color_face2 == FACE_IDX_BOTTOM) {
            printf("F2L 9\n");
            if (corner_white_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);            
        }
    
        // F2L 10 work
        else if (edge_color_face == face_on_the_other_side_of_white && edge_color_face2 == FACE_IDX_BOTTOM && corner_color_face == FACE_IDX_BOTTOM) {
            printf("F2L 10\n");
            if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            // move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }
    
        // F2L 11 work
        else if (edge_color_face2 == face_before_corner_white_face && edge_color_face == FACE_IDX_BOTTOM && corner_color_face2 == FACE_IDX_BOTTOM) {
            printf("F2L 11\n");
            if (corner_white_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);          
        }
    
        // F2L 12 work
        else if (edge_color_face == face_after_corner_white_face && edge_color_face2 == FACE_IDX_BOTTOM && corner_color_face == FACE_IDX_BOTTOM) {
            printf("F2L 12\n");
            if (corner_white_face == face2) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }
            //R' U2 R2 U R2 U R
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
        }

        // F2L 13 work
        else if (edge_color_face2 == corner_white_face && edge_color_face == FACE_IDX_BOTTOM && corner_color_face2 == FACE_IDX_BOTTOM) {
            printf("F2L 13\n");
            if (corner_white_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }
    
        // F2L 14 work
        else if (edge_color_face == corner_white_face && edge_color_face2 == FACE_IDX_BOTTOM && corner_color_face == FACE_IDX_BOTTOM) {
            printf("F2L 14\n");
            if (corner_white_face == face2) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }
    
        // Split Pair by Going Over

        // F2L 15 work
        else if (edge_color_face == corner_white_face && edge_color_face2 == FACE_IDX_BOTTOM && corner_color_face2 == FACE_IDX_BOTTOM) {
            printf("F2L 15\n");
            if (corner_white_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }
    
        // F2L 16 work
        else if (edge_color_face2 == corner_white_face && edge_color_face == FACE_IDX_BOTTOM && corner_color_face == FACE_IDX_BOTTOM) {
            printf("F2L 16\n");
            if (corner_white_face == face2) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
        }
    
        // F2L 17 work
        else if (edge_color_face == corner_color_face2 && edge_color_face2 == FACE_IDX_BOTTOM && corner_white_face == FACE_IDX_BOTTOM) {
            printf("F2L 17\n");
            if (corner_color_face2 == face2) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (corner_color_face2 == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_color_face2 == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }

        // F2L 18 work
        else if (edge_color_face2 == corner_color_face && edge_color_face == FACE_IDX_BOTTOM && corner_white_face == FACE_IDX_BOTTOM) {
            printf("F2L 18\n");
            if (corner_color_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_color_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_color_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }
            for (int i = 0; i < 2; i++) {
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
        }
    
        
        // Pair Made on Side

        // F2L 19 work
        else if (edge_color_face == face_on_the_other_side_of_color && edge_color_face2 == FACE_IDX_BOTTOM && corner_white_face == FACE_IDX_BOTTOM) {
            printf("F2L 19\n");
            if (corner_color_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_color_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_color_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            for (int i = 0; i < 2; i++) {
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);   
        }
    
        // F2L 20
        else if (edge_color_face2 == face_on_the_other_side_of_color2 && edge_color_face == FACE_IDX_BOTTOM && corner_white_face == FACE_IDX_BOTTOM) {
            printf("F2L 20\n");
            if (corner_color_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_color_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_color_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);          
        }
    
        // F2L 21 work
        else if (edge_color_face == face_on_the_other_side_of_color2 && edge_color_face2 == FACE_IDX_BOTTOM && corner_white_face == FACE_IDX_BOTTOM) {
            printf("F2L 21\n");

            if (corner_color_face2 == face2) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (corner_color_face2 == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_color_face2 == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }
    
        // F2L 22 work
        else if (edge_color_face2 == face_on_the_other_side_of_color && edge_color_face == FACE_IDX_BOTTOM && corner_white_face == FACE_IDX_BOTTOM) {
            printf("F2L 22\n");
            if (corner_color_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_color_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_color_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
        }
    

        // Weird

        // F2L 23 work
        else if (edge_color_face == corner_color_face && edge_color_face2 == FACE_IDX_BOTTOM && corner_white_face == FACE_IDX_BOTTOM) {
            printf("F2L 23\n");
            if (corner_color_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_color_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_color_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }

        // F2L 24 work
        else if (edge_color_face2 == corner_color_face2 && edge_color_face == FACE_IDX_BOTTOM && corner_white_face == FACE_IDX_BOTTOM) {
            printf("F2L 24\n");
            if (corner_color_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_color_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_color_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }

        // F2L 25
        else if (edge_color_face2 == FACE_IDX_BOTTOM && corner_white_face == FACE_IDX_TOP && corner_color_face == face) {
            printf("F2L 25\n");
            if (edge_color_face == face2) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (edge_color_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (edge_color_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }

        // F2L 26 work
        else if (edge_color_face == FACE_IDX_BOTTOM && corner_white_face == FACE_IDX_TOP && corner_color_face == face) {
            printf("F2L 26\n");
            if (edge_color_face2 == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (edge_color_face2 == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (edge_color_face2 == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
        }
            
        // F2L 27 work
        else if (edge_color_face2 == FACE_IDX_BOTTOM && corner_color_face == FACE_IDX_TOP) {
            printf("F2L 27\n");
            if (edge_color_face == face2) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (edge_color_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (edge_color_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }

        // F2L 28 work
        else if (edge_color_face == FACE_IDX_BOTTOM && corner_color_face2 == FACE_IDX_TOP) {
            printf("F2L 28\n");
            if (edge_color_face2 == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (edge_color_face2 == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (edge_color_face2 == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
        }

        // F2L 29
        else if (edge_color_face == FACE_IDX_BOTTOM && corner_color_face == FACE_IDX_TOP) {
            printf("F2L 29\n");
            if (edge_color_face2 == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (edge_color_face2 == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (edge_color_face2 == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            for (int i = 0; i < 2; i++) {
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }
        }

        // F2L 30 work
        else if (edge_color_face2 == FACE_IDX_BOTTOM && corner_color_face2 == FACE_IDX_TOP) {
            printf("F2L 30\n");
            if (edge_color_face == face2) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            } else if (edge_color_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (edge_color_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }

        // Edge in Place, Corner in D face

        // F2L 31 work
        else if (edge_color_face == face2 && edge_color_face2 == face && corner_white_face == FACE_IDX_BOTTOM) {
            printf("F2L 31\n");
            if (corner_color_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_color_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_color_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
        }

        // F2L 32 work
        else if (edge_color_face == face && edge_color_face2 == face2 && corner_white_face == FACE_IDX_BOTTOM) {
            printf("F2L 32\n");
            if (corner_color_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_color_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_color_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            for (int i = 0; i < 3; i++) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }
        }

        // F2L 33 work
        else if (edge_color_face == face && edge_color_face2 == face2 && corner_color_face2 == FACE_IDX_BOTTOM) {
            printf("F2L 33\n");
            if (corner_white_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }

        // F2L 34 work
        else if (edge_color_face == face && edge_color_face2 == face2 && corner_color_face == FACE_IDX_BOTTOM) {
            printf("F2L 34\n");
            if (corner_color_face2 == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_color_face2 == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_color_face2 == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }

        // F2L 35 work
        else if (edge_color_face == face2 && edge_color_face2 == face && corner_color_face2 == FACE_IDX_BOTTOM) {
            printf("F2L 35\n");
            if (corner_white_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
        }

        // F2L 36 work
        else if (edge_color_face == face2 && edge_color_face2 == face && corner_color_face == FACE_IDX_BOTTOM) {
            printf("F2L 36\n");
            if (corner_white_face == face) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            } else if (corner_white_face == face4) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            } else if (corner_white_face == face3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }

        // Edge and Corner in Place
        
        // F2L 37
        // solved state

        // F2L 38 work
        else if (edge_color_face == face2 && edge_color_face2 == face && corner_white_face == FACE_IDX_TOP && corner_color_face2 == face2) {
            printf("F2L 38\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }

        // F2L 39
        else if (edge_color_face == face && edge_color_face2 == face2 && corner_color_face == FACE_IDX_TOP && corner_color_face2 == face) {
            printf("F2L 39\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }

        // F2L 40
        else if (edge_color_face == face && edge_color_face2 == face2 && corner_color_face2 == FACE_IDX_TOP && corner_color_face == face2) {
            printf("F2L 40\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
        }

        // F2L 41
        else if (edge_color_face == face2 && edge_color_face2 == face && corner_color_face == FACE_IDX_TOP && corner_color_face2 == face) {
            printf("F2L 41\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }

        // F2L 42 work
        else if (edge_color_face == face2 && edge_color_face2 == face && corner_color_face2 == FACE_IDX_TOP && corner_color_face == face2) {
            printf("F2L 42\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }
        
    }   

}

static void solve_OLL(RGBColor (*cubeColors)[9], MoveSequence* solution) {
    printf("Solving OLL...\n");
    int positions_bottom[9];
    int positions_sides[4][3];

    RGBColor (*temp_cubeColors)[9] = malloc(sizeof(RGBColor[6][9]));
    copy_cube_state(cubeColors, temp_cubeColors);

    rotate_face_colors(temp_cubeColors, FACE_IDX_BOTTOM, ROTATE_CLOCKWISE);
    get_yellow_positions(temp_cubeColors, positions_bottom, positions_sides);

    FaceIndex face = FACE_IDX_RIGHT;
    FaceIndex face2 = FACE_IDX_BACK;
    FaceIndex face3 = FACE_IDX_LEFT;
    FaceIndex face4 = FACE_IDX_FRONT;

    Move moves[] = {MOVE_D_PRIME, MOVE_D2, MOVE_D};



    for (int i = 0; i < 4; i++) {
        if (bottom_equal(positions_bottom, b_OLL_1) && sides_equal(positions_sides, s_OLL_1)) {
            printf("OLL 1\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_2) && sides_equal(positions_sides, s_OLL_2)) {
            printf("OLL 2\n");

            // F R U R' U' F' U2 F U R U' R' F'
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_3) && sides_equal(positions_sides, s_OLL_3)) {
            printf("OLL 3\n");

            // U F U2 F R' F' R U R U R' U F'
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_4) && sides_equal(positions_sides, s_OLL_4)) {
            printf("OLL 4\n");

            // R' U' F' U' F R U' R' F' U' F U' R
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_5) && sides_equal(positions_sides, s_OLL_5)) {
            printf("OLL 5\n");

            // F R U R' U' F' U' F R U R' U' F'
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_6) && sides_equal(positions_sides, s_OLL_6)) {
            printf("OLL 6\n");

            // U2 F' U' F2 R' F' R U R U2 R' (U2 не было)
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_7) && sides_equal(positions_sides, s_OLL_7)) {
            printf("OLL 7\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_8) && sides_equal(positions_sides, s_OLL_8)) {
            printf("OLL 8\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_9) && sides_equal(positions_sides, s_OLL_9)) {
            printf("OLL 9\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_10) && sides_equal(positions_sides, s_OLL_10)) {
            printf("OLL 10\n");

            // U' R U R' U R' F R F' R U2 R'
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);          
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_11) && sides_equal(positions_sides, s_OLL_11)) {
            printf("OLL 11\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_12) && sides_equal(positions_sides, s_OLL_12)) {
            printf("OLL 12\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_13) && sides_equal(positions_sides, s_OLL_13)) {
            printf("OLL 13\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_14) && sides_equal(positions_sides, s_OLL_14)) {
            printf("OLL 14\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_15) && sides_equal(positions_sides, s_OLL_15)) {
            printf("OLL 15\n");

            // U2 F R U R' U' F' U R U R' U R U2 R'
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_16) && sides_equal(positions_sides, s_OLL_16)) {
            printf("OLL 16\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_17) && sides_equal(positions_sides, s_OLL_17)) {
            printf("OLL 17\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_18) && sides_equal(positions_sides, s_OLL_18)) {
            printf("OLL 18\n");

            // U' F R' F' R U R U' R' U F R U R' U' F'
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_19) && sides_equal(positions_sides, s_OLL_19)) {
            printf("OLL 19\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_20) && sides_equal(positions_sides, s_OLL_20)) {
            printf("OLL 20\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_TOP, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_TOP, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_180), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_21) && sides_equal(positions_sides, s_OLL_21)) {
            printf("OLL 21\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_22) && sides_equal(positions_sides, s_OLL_22)) {
            printf("OLL 22\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_23) && sides_equal(positions_sides, s_OLL_23)) {
            printf("OLL 23\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_TOP, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_TOP, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_24) && sides_equal(positions_sides, s_OLL_24)) {
            printf("OLL 24\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_25) && sides_equal(positions_sides, s_OLL_25)) {
            printf("OLL 25\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_26) && sides_equal(positions_sides, s_OLL_26)) {
            printf("OLL 26\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_27) && sides_equal(positions_sides, s_OLL_27)) {
            printf("OLL 27\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_28) && sides_equal(positions_sides, s_OLL_28)) {
            printf("OLL 28\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_29) && sides_equal(positions_sides, s_OLL_29)) {
            printf("OLL 29\n");

            // U R U R' U' R U' R' F' U' F R U R'
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_30) && sides_equal(positions_sides, s_OLL_30)) {
            printf("OLL 30\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_31) && sides_equal(positions_sides, s_OLL_31)) {
            printf("OLL 31\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_32) && sides_equal(positions_sides, s_OLL_32)) {
            printf("OLL 32\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_33) && sides_equal(positions_sides, s_OLL_33)) {
            printf("OLL 33\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_34) && sides_equal(positions_sides, s_OLL_34)) {
            printf("OLL 34\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_35) && sides_equal(positions_sides, s_OLL_35)) {
            printf("OLL 35\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_36) && sides_equal(positions_sides, s_OLL_36)) {
            printf("OLL 36\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_37) && sides_equal(positions_sides, s_OLL_37)) {
            printf("OLL 37\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_38) && sides_equal(positions_sides, s_OLL_38)) {
            printf("OLL 38\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_39) && sides_equal(positions_sides, s_OLL_39)) {
            printf("OLL 39\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_40) && sides_equal(positions_sides, s_OLL_40)) {
            printf("OLL 40\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_41) && sides_equal(positions_sides, s_OLL_41)) {
            printf("OLL 41\n");

            // R U' R' U2 R U B U' B' U' R'
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }   
        else if (bottom_equal(positions_bottom, b_OLL_42) && sides_equal(positions_sides, s_OLL_42)) {
            printf("OLL 42\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_43) && sides_equal(positions_sides, s_OLL_43)) {
            printf("OLL 43\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_44) && sides_equal(positions_sides, s_OLL_44)) {
            printf("OLL 44\n");

            // B U L U' L' B'
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_45) && sides_equal(positions_sides, s_OLL_45)) {
            printf("OLL 45\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_46) && sides_equal(positions_sides, s_OLL_46)) {
            printf("OLL 46\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_47) && sides_equal(positions_sides, s_OLL_47)) {
            printf("OLL 47\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_48) && sides_equal(positions_sides, s_OLL_48)) {
            printf("OLL 48\n");

            // F R U R' U' R U R' U' F'
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_49) && sides_equal(positions_sides, s_OLL_49)) {
            printf("OLL 49\n");

            // R B' R2 F R2 B R2 F' R
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            break;
        }   
        else if (bottom_equal(positions_bottom, b_OLL_50) && sides_equal(positions_sides, s_OLL_50)) {
            printf("OLL 50\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            break;
        }
        else if (bottom_equal(positions_bottom, b_OLL_51) && sides_equal(positions_sides, s_OLL_51)) {
            printf("OLL 51\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        } 
        else if (bottom_equal(positions_bottom, b_OLL_52) && sides_equal(positions_sides, s_OLL_52)) {
            printf("OLL 52\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            break;
        } 
        else if (bottom_equal(positions_bottom, b_OLL_53) && sides_equal(positions_sides, s_OLL_53)) {
            printf("OLL 53\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        } 
        else if (bottom_equal(positions_bottom, b_OLL_54) && sides_equal(positions_sides, s_OLL_54)) {
            printf("OLL 54\n");

            // F' L' U' L U F L' U' L U L F' L' F
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            break;
        } 
        else if (bottom_equal(positions_bottom, b_OLL_55) && sides_equal(positions_sides, s_OLL_55)) {
            printf("OLL 55\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        } 
        else if (bottom_equal(positions_bottom, b_OLL_56) && sides_equal(positions_sides, s_OLL_56)) {
            printf("OLL 56\n");

            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        } 
        else if (bottom_equal(positions_bottom, b_OLL_57) && sides_equal(positions_sides, s_OLL_57)) {
            printf("OLL 57\n");

            // L' R U R' U' L R' F R F'
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            break;
        } else {
            printf("Position unknown\n");
        }

        face = (face % 4) + 1;
        face2 = (face2 % 4) + 1;
        face3 = (face3 % 4) + 1;
        face4 = (face4 % 4) + 1;

        rotate_face_colors(temp_cubeColors, FACE_IDX_BOTTOM, ROTATE_CLOCKWISE);
        get_yellow_positions(temp_cubeColors, positions_bottom, positions_sides);
    }
    free(temp_cubeColors);
}

static void solve_PLL(RGBColor (*cubeColors)[9], MoveSequence* solution) {
    printf("Solve PLL\n");

    if (is_cube_solved(cubeColors)) {
        printf("Cube is already solved!\n");
        return;
    }

    int positions_sides[4][3];
    get_side_positions(cubeColors, positions_sides);



    Move moves[] = {MOVE_D_PRIME, MOVE_D2, MOVE_D};
    Move return_moves[] = {MOVE_D, MOVE_D2, MOVE_D_PRIME};


    FaceIndex face = FACE_IDX_FRONT;
    FaceIndex face2 = FACE_IDX_RIGHT;
    FaceIndex face3 = FACE_IDX_BACK;
    FaceIndex face4 = FACE_IDX_LEFT;
    int id1 = 0, id2 = 1, id3 = 2, id4 = 3;
    bool f = false;

    for (int i = 0; i < 4; i++) {

        // printf("positions_sides[%d][0]: %d, positions_sides[%d][1]: %d, positions_sides[%d][2]: %d\n", id1, positions_sides[id1][0], id1, positions_sides[id1][1], id1, positions_sides[id1][2]);
        // printf("positions_sides[%d][0]: %d, positions_sides[%d][1]: %d, positions_sides[%d][2]: %d\n", id2, positions_sides[id2][0], id2, positions_sides[id2][1], id2, positions_sides[id2][2]);
        // printf("positions_sides[%d][0]: %d, positions_sides[%d][1]: %d, positions_sides[%d][2]: %d\n", id3, positions_sides[id3][0], id3, positions_sides[id3][1], id3, positions_sides[id3][2]);
        // printf("positions_sides[%d][0]: %d, positions_sides[%d][1]: %d, positions_sides[%d][2]: %d\n", id4, positions_sides[id4][0], id4, positions_sides[id4][1], id4, positions_sides[id4][2]);

        // If all the corners are in place
        if (
            positions_sides[id1][0] == 1 && positions_sides[id1][2] == 1 && 
            positions_sides[id2][0] == 2 && positions_sides[id2][2] == 2 && 
            positions_sides[id3][0] == 3 && positions_sides[id3][2] == 3 && 
            positions_sides[id4][0] == 4 && positions_sides[id4][2] == 4
        ) {
            printf("All corners are in place\n");
            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return;
                }
            }

            // H Permutation
            if (positions_sides[0][1] == 3 && positions_sides[1][1] == 4 && positions_sides[2][1] == 1 && positions_sides[3][1] == 2) {
                printf("H Permutation\n");

                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
                return;
            } 

            // Z Permutation
            if (positions_sides[0][1] == 2 && positions_sides[1][1] == 1 && positions_sides[2][1] == 4 && positions_sides[3][1] == 3) {
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                f = true;
            }
            if ((positions_sides[0][1] == 4 && positions_sides[3][1] == 1 && positions_sides[1][1] == 3 && positions_sides[2][1] == 2) || f) {
                printf("Z Permutation\n");

                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_180), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
                
                if (f) {
                    move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                } else {
                    move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
                }
                return;
            }
            
            // U Permutations
            for (int j = 0; j < 4; j++) {
                // If one side has all the same color
                if (positions_sides[j][0] == positions_sides[j][1] && positions_sides[j][2] == positions_sides[j][1]) {
                    int non_color = positions_sides[j][0];

                    int next_color = (non_color % 4) + 1;
                    int prev_id = j == 0? 3 : j - 1;

                    // U Permutation : b
                    if (positions_sides[prev_id][1] == next_color) {
                        printf("U Permutation: b\n");

                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
                    } else {
                        printf("U Permutation: a\n");

                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
                    }
                    return;
                }
                face = (face % 4) + 1;
                face2 = (face2 % 4) + 1;
                face3 = (face3 % 4) + 1;
                face4 = (face4 % 4) + 1;
            }
        }

        // If all the edges are in place
        else if (
            positions_sides[id1][1] == 1 &&
            positions_sides[id2][1] == 2 &&
            positions_sides[id3][1] == 3 &&
            positions_sides[id4][1] == 4
        ) 
        {
            printf("All edges are in place\n");
            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return;
                }
            }
            
            for (int j = 0; j < 4; j++) {
                int j_next = j == 3? 0: j + 1;
                int j_prev = j == 0? 3 : j - 1;

                // Aa/Ab Permutation
                // Find the corner with all the same color
                if (positions_sides[j][1] == positions_sides[j][2] && positions_sides[j_next][0] == positions_sides[j_next][1]) {
                    if (positions_sides[j][0] != positions_sides[j_prev][1]) {
                        printf("Aa Permutation\n");

                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_180), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_180), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
                        
                    } else {
                        printf("Ab Permutation\n");

                        move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_180), cubeColors);
                    }
                    return;
                } 
                
                // E Permutation
                if (positions_sides[j][1] == positions_sides[j_next][0] && positions_sides[j][1] == positions_sides[j_prev][2]) {
                    printf("E Permutation\n");
                    
                    move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_180), cubeColors);
                    move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                    move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
                    for (int i = 0; i < 3; i++) {
                        move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
                        move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                    }
                    move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
                    move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                    move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_180), cubeColors);
                    return;
                }
                
                face = (face % 4) + 1;
                face2 = (face2 % 4) + 1;
                face3 = (face3 % 4) + 1;
                face4 = (face4 % 4) + 1;
            }
        }
        
        id1 = id1 == 3? 0 : id1 + 1;
        id2 = id2 == 3? 0 : id2 + 1;
        id3 = id3 == 3? 0 : id3 + 1;
        id4 = id4 == 3? 0 : id4 + 1;
    }

    for (int i = 0; i < 4; i++) {
        // if one side has all the same color
        if (
            positions_sides[id1][0] == positions_sides[id1][1] && 
            positions_sides[id1][2] == positions_sides[id1][1]
        ) {
            printf("One side has all the same color\n");

            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return;
                }
            }

            // F Permutation
            if (positions_sides[2][1] == positions_sides[1][2] && positions_sides[2][1] == positions_sides[3][0]) {
                printf("F Permutation\n");

                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }
            // J Permutation: a
            else if (positions_sides[2][1] == positions_sides[2][2] && positions_sides[3][0] == positions_sides[1][2]) {
                printf("J Permutation: a\n");

                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            }
            // J Permutation: b
            else if (positions_sides[2][1] == positions_sides[2][0] && positions_sides[1][2] == positions_sides[3][0]) {
                printf("J Permutation: b\n");

                move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_180), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);            
            }
            int idx = (positions_sides[0][1] - 1);
            printf("idx: %d\n", idx);
            if (idx != 0) {
                move_sequence_add(solution, return_moves[idx-1], cubeColors);
            }    
            return;
        }
        id1 = id1 == 3? 0 : id1 + 1;
        id2 = id2 == 3? 0 : id2 + 1;
        id3 = id3 == 3? 0 : id3 + 1;
        id4 = id4 == 3? 0 : id4 + 1;
    }

    for (int i = 0; i < 4; i++) {      
        // V Permutation
         if (
            positions_sides[id1][2] == positions_sides[id1][1] &&
            positions_sides[id2][1] == positions_sides[id2][0] &&
            positions_sides[id2][2] == positions_sides[id3][1]
        ) {
            printf("V Permutation\n");

            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return;
                }
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
                
            int idx = (positions_sides[0][1] - 1);
            printf("idx: %d\n", idx);
            if (idx != 0) {
                move_sequence_add(solution, return_moves[idx-1], cubeColors);
            }
            return;
        }

        // Y Permutation
        else if (
            positions_sides[id1][2] == positions_sides[id1][1] &&
            positions_sides[id4][1] == positions_sides[id4][0]
        ) {
            printf("Y Permutation\n");

            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return;
                }
            }   

            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_TOP, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_TOP, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);


            int idx = (positions_sides[0][1] - 1);
            printf("idx: %d\n", idx);
            if (idx != 0) {
                move_sequence_add(solution, return_moves[idx-1], cubeColors);
            }
            return;
        }

        // N Permutation : a
        else if (
            positions_sides[id1][0] == positions_sides[id1][1] &&
            positions_sides[id3][0] == positions_sides[id3][1]
        ) {
            printf("N Permutation : a\n");

            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return;
                }
            }

            for (int i = 0; i < 2; i++) {
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            }

            int idx = (positions_sides[0][1] - 1);
            printf("idx: %d\n", idx);
            if (idx != 0) {
                move_sequence_add(solution, return_moves[idx-1], cubeColors);
            }
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            return;
        } 
        
        // N Permutation : b
        else if (
            positions_sides[id1][2] == positions_sides[id1][1] &&
            positions_sides[id3][2] == positions_sides[id3][1]
        ) {
            printf("N Permutation : b\n");

            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return;
                }   
            }
            for (int i = 0; i < 2; i++) {
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
                move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            }
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            
            int idx = (positions_sides[0][1] - 1);
            printf("idx: %d\n", idx);
            if (idx != 0) {
                move_sequence_add(solution, return_moves[idx-1], cubeColors);
            }
            return;
        }

        // G Permutation : a
        else if (
            positions_sides[id1][0] == positions_sides[id1][1] && 
            positions_sides[id4][1] == positions_sides[id2][0] &&
            positions_sides[id4][1] == positions_sides[id2][2]
        ) {
            printf("G Permutation : a\n");
            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return;
                }   
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            
            int idx = (positions_sides[0][1] - 1);
            printf("idx: %d\n", idx);
            if (idx != 0) {
                move_sequence_add(solution, moves[idx-1], cubeColors);
            }    
            return;
        }
        // G Permutation : b
        else if (
            positions_sides[id1][0] == positions_sides[id1][1] && 
            positions_sides[id4][2] == positions_sides[id2][0] &&
            positions_sides[id4][2] == positions_sides[id3][1]
        ) {
            printf("G Permutation : b\n");
            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return;
                }   
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_TOP, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_TOP, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);

            int idx = (positions_sides[0][1] - 1);
            printf("idx: %d\n", idx);
            if (idx != 0) {
                move_sequence_add(solution, return_moves[idx-1], cubeColors);
            }
            return;
        }
        // G Permutation : c
        else if (
            positions_sides[id1][2] == positions_sides[id1][1] && 
            positions_sides[id2][1] == positions_sides[id4][0] &&
            positions_sides[id4][2] == positions_sides[id2][1]
        ) {
            printf("G Permutation : c\n");

            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return;
                }   
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);

            int idx = (positions_sides[0][1] - 1);
            printf("idx: %d\n", idx);
            if (idx != 0) {
                move_sequence_add(solution, moves[idx-1], cubeColors);
            }
            return;
        }       
        // G Permutation : d
        else if (
            positions_sides[id1][2] == positions_sides[id1][1] && 
            positions_sides[id2][0] == positions_sides[id3][1] &&
            positions_sides[id4][2] == positions_sides[id3][1]
        ) {
            printf("G Permutation : d\n");

            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return;
                }   
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            
            int idx = (positions_sides[3][1] - 1);
            printf("idx: %d\n", idx);
            if (idx != 0) {
                move_sequence_add(solution, return_moves[idx-1], cubeColors);
            }
            return;
        }
        
        // T Permutation
        else if (
            positions_sides[id1][2] == positions_sides[id1][1] && 
            positions_sides[id3][1] == positions_sides[id3][0]
        ) {
            printf("T Permutation\n");

            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return; 
                }
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face, ROTATE_COUNTERCLOCKWISE), cubeColors);
        }


        // R Permutation : a
        else if (
            positions_sides[id1][2] == positions_sides[id1][1] &&
            positions_sides[id2][1] == positions_sides[id3][0] &&
            positions_sides[id2][1] == positions_sides[id4][2]
        ) {
            printf("R Permutation : a\n");

            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return; 
                }
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face2, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);

            int idx = (positions_sides[0][1] - 1);
            printf("idx: %d\n", idx);
            if (idx != 0) {
                move_sequence_add(solution, return_moves[idx-1], cubeColors);
            }
            return;
        }
        
        // R Permutation : b
        else if (
            positions_sides[id1][0] == positions_sides[id1][1] &&
            positions_sides[id4][1] == positions_sides[id2][0] &&
            positions_sides[id4][1] == positions_sides[id3][2]
        ) {
            printf("R Permutation : b\n");

            if (id1 != 0) {
                move_sequence_add(solution, moves[id1-1], cubeColors);
                get_side_positions(cubeColors, positions_sides);
                if (is_cube_solved(cubeColors)) {
                    return;
                }
            }

            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_CLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face4, ROTATE_COUNTERCLOCKWISE), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(face3, ROTATE_180), cubeColors);
            move_sequence_add(solution, get_move_from_face_and_direction(FACE_IDX_BOTTOM, ROTATE_COUNTERCLOCKWISE), cubeColors);

            int idx = (positions_sides[0][1] - 1);
            printf("idx: %d\n", idx);
            if (idx != 0) {
                move_sequence_add(solution, return_moves[idx-1], cubeColors);
            }
            return;
        }
            
                id1 = id1 == 3? 0 : id1 + 1;
        id2 = id2 == 3? 0 : id2 + 1;
        id3 = id3 == 3? 0 : id3 + 1;
        id4 = id4 == 3? 0 : id4 + 1;
    }
}


char** cube_solver_solve(Scene* scene, bool* isSolved) {
    if (!scene) {
        printf("Error: Invalid scene\n");
        return NULL;
    }
    
    printf("Starting Rubik's cube solver...\n");
    
    if (is_cube_solved(scene->cubeColors)) {
        printf("Cube is already solved!\n");
        char** moveSequence = malloc(sizeof(char*));
        moveSequence[0] = NULL;
        *isSolved = true;
        return moveSequence;
    }
    
    RGBColor working_colors[6][9];
    copy_cube_state(scene->cubeColors, working_colors);
    
    MoveSequence solution;
    move_sequence_init(&solution);
    
    solve_white_cross(working_colors, &solution);
    solve_F2L(working_colors, &solution);
    solve_OLL(working_colors, &solution);
    solve_PLL(working_colors, &solution);
    printf("Solver completed with %d moves\n", solution.count);
    
    char** moveSequence = malloc((solution.count + 1) * sizeof(char*));
    if (!moveSequence) {
        move_sequence_destroy(&solution);
        return NULL;
    }
    
    for (int i = 0; i < solution.count; i++) {
        const char* moveStr = move_to_string(solution.moves[i]);
        moveSequence[i] = malloc((strlen(moveStr) + 1) * sizeof(char));
        if (moveSequence[i]) {
            strcpy(moveSequence[i], moveStr);
        } else {
            for (int j = 0; j < i; j++) {
                free(moveSequence[j]);
            }
            free(moveSequence);
            move_sequence_destroy(&solution);
            return NULL;
        }
    }
    
    moveSequence[solution.count] = NULL;
    
    move_sequence_destroy(&solution);

    if (is_cube_solved(working_colors)) {
        *isSolved = true;
    }
    else {
        *isSolved = false;
    }
    
    return moveSequence;
} 

./src/solver/cube_solver.h:

#ifndef CUBE_SOLVER_H
#define CUBE_SOLVER_H

#include <stdbool.h>
#include "../scene/scene.h"

typedef enum {
    MOVE_U,
    MOVE_U_PRIME,
    MOVE_U2,
    MOVE_D,
    MOVE_D_PRIME,
    MOVE_D2,
    MOVE_F, 
    MOVE_F_PRIME, 
    MOVE_F2,
    MOVE_B, 
    MOVE_B_PRIME,
    MOVE_B2, 
    MOVE_R, 
    MOVE_R_PRIME, 
    MOVE_R2, 
    MOVE_L, 
    MOVE_L_PRIME, 
    MOVE_L2, 
    MOVE_COUNT
} Move;


typedef struct {
    Move* moves;
    int count;
    int capacity;
} MoveSequence;

char** cube_solver_solve(Scene* scene, bool* isSolved);
void move_sequence_init(MoveSequence* sequence);
void move_sequence_add(MoveSequence* sequence, Move move, RGBColor (*cubeColors)[9]);
void move_sequence_destroy(MoveSequence* sequence);
void move_sequence_print(const MoveSequence* sequence);

Move get_move_from_face_and_direction(FaceIndex face, RotationDirection direction);
void apply_move_to_cube_colors(RGBColor (*cubeColors)[9], Move move);
void copy_cube_state(const RGBColor (*source)[9], RGBColor (*dest)[9]);
bool is_cube_solved(const RGBColor (*cubeColors)[9]);

const char* move_to_string(Move move);
FaceIndex move_to_face(Move move);
RotationDirection move_to_direction(Move move);

#endif /* CUBE_SOLVER_H */ 

./src/solver/oll.h:

// OLL 1
static int b_OLL_1[9] = 
    {0, 0, 0, 
     0, 1, 0, 
     0, 0, 0};

static int s_OLL_1[4][3] = 
    {0, 1, 0, 
     1, 1, 1, 
     0, 1, 0, 
     1, 1, 1};

// OLL 2
static int b_OLL_2[9] = 
    {0, 0, 0, 
     0, 1, 0, 
     0, 0, 0};

static int s_OLL_2[4][3] = 
    {0, 1, 1, 
     0, 1, 0, 
     1, 1, 0, 
     1, 1, 1};

// OLL 3
static int b_OLL_3[9] = 
    {0, 0, 1, 
     0, 1, 0, 
     0, 0, 0};

static int s_OLL_3[4][3] = 
    {1, 1, 0, 
     0, 1, 0, 
     1, 1, 0, 
     1, 1, 0};

// OLL 4
static int b_OLL_4[9] = 
    {0, 0, 1, 
     0, 1, 0, 
     0, 0, 0};

static int s_OLL_4[4][3] = 
    {0, 1, 0, 
     0, 1, 1, 
     0, 1, 1, 
     0, 1, 1};

// OLL 5
static int b_OLL_5[9] = 
    {0, 0, 0, 
     0, 1, 1, 
     0, 1, 1};

static int s_OLL_5[4][3] = 
    {1, 1, 0, 
     1, 0, 0, 
     0, 0, 0, 
     1, 1, 0};

// OLL 6
static int b_OLL_6[9] = 
    {0, 0, 0, 
     1, 1, 0, 
     1, 1, 0};

static int s_OLL_6[4][3] = 
    {0, 1, 1, 
     0, 1, 1, 
     0, 0, 0, 
     0, 0, 1};

// OLL 7
static int b_OLL_7[9] = 
    {0, 1, 0, 
     1, 1, 0, 
     1, 0, 0};

static int s_OLL_7[4][3] = 
    {1, 0, 0, 
     1, 1, 0, 
     1, 1, 0, 
     0, 0, 0};

// OLL 8
static int b_OLL_8[9] = 
    {0, 1, 0, 
     0, 1, 1, 
     0, 0, 1};

static int s_OLL_8[4][3] = 
    {0, 0, 1, 
     0, 0, 0, 
     0, 1, 1, 
     0, 1, 1};

// OLL 9
static int b_OLL_9[9] = 
    {0, 1, 0, 
     0, 1, 1, 
     1, 0, 0};

static int s_OLL_9[4][3] = 
    {0, 0, 1, 
     0, 0, 1, 
     0, 1, 0, 
     0, 1, 1};

// OLL 10
static int b_OLL_10[9] = 
    {0, 1, 0, 
     1, 1, 0, 
     0, 0, 1};

static int s_OLL_10[4][3] = 
    {1, 0, 0, 
     1, 1, 0, 
     0, 1, 0, 
     1, 0, 0};

// OLL 11
static int b_OLL_11[9] = 
    {1, 0, 0, 
     1, 1, 0, 
     0, 1, 0};

static int s_OLL_11[4][3] = 
    {0, 1, 0, 
     1, 1, 0, 
     1, 0, 0, 
     1, 0, 0};

// OLL 12
static int b_OLL_12[9] = 
    {0, 0, 1, 
     0, 1, 1, 
     0, 1, 0};

static int s_OLL_12[4][3] = 
    {0, 1, 0, 
     0, 0, 1, 
     0, 0, 1, 
     0, 1, 1};

// OLL 13
static int b_OLL_13[9] = 
    {0, 0, 0, 
     1, 1, 1, 
     1, 0, 0};

static int s_OLL_13[4][3] = 
    {1, 1, 0, 
     1, 0, 0, 
     1, 1, 0, 
     0, 0, 0};

// OLL 14
static int b_OLL_14[9] = 
    {0, 0, 0, 
     1, 1, 1, 
     0, 0, 1};

static int s_OLL_14[4][3] = 
    {0, 1, 1, 
     0, 0, 0, 
     0, 1, 1, 
     0, 0, 1};

// OLL 15
static int b_OLL_15[9] = 
    {0, 0, 0, 
     1, 1, 1, 
     0, 0, 1};

static int s_OLL_15[4][3] = 
    {1, 1, 0, 
     1, 0, 0, 
     0, 1, 0, 
     1, 0, 0};

// OLL 16
static int b_OLL_16[9] = 
    {0, 0, 0, 
     1, 1, 1, 
     1, 0, 0};

static int s_OLL_16[4][3] = 
    {0, 1, 1, 
     0, 0, 1, 
     0, 1, 0, 
     0, 0, 1};

// OLL 17
static int b_OLL_17[9] = 
    {1, 0, 0, 
     0, 1, 0, 
     0, 0, 1};

static int s_OLL_17[4][3] = 
    {0, 1, 1, 
     0, 1, 0, 
     0, 1, 0, 
     1, 1, 0};

// OLL 18
static int b_OLL_18[9] = 
    {0, 0, 1, 
     0, 1, 0, 
     0, 0, 1};

static int s_OLL_18[4][3] = 
    {0, 1, 0, 
     0, 1, 0, 
     0, 1, 0, 
     1, 1, 1};

// OLL 19
static int b_OLL_19[9] = 
    {1, 0, 1, 
     0, 1, 0, 
     0, 0, 0};

static int s_OLL_19[4][3] = 
    {0, 1, 0, 
     0, 1, 1, 
     0, 1, 0, 
     1, 1, 0};

// OLL 20
static int b_OLL_20[9] = 
    {1, 0, 1, 
     0, 1, 0, 
     1, 0, 1};

static int s_OLL_20[4][3] = 
    {0, 1, 0, 
     0, 1, 0, 
     0, 1, 0, 
     0, 1, 0};

// OLL 21
static int b_OLL_21[9] = 
    {0, 1, 0, 
     1, 1, 1, 
     0, 1, 0};

static int s_OLL_21[4][3] = 
    {0, 0, 0, 
     1, 0, 1, 
     0, 0, 0, 
     1, 0, 1};

// OLL 22
static int b_OLL_22[9] = 
    {0, 1, 0, 
     1, 1, 1, 
     0, 1, 0};

static int s_OLL_22[4][3] = 
    {0, 0, 1, 
     0, 0, 0, 
     1, 0, 0, 
     1, 0, 1};

// OLL 23
static int b_OLL_23[9] = 
    {0, 1, 0, 
     1, 1, 1, 
     1, 1, 1};

static int s_OLL_23[4][3] = 
    {1, 0, 1, 
     0, 0, 0, 
     0, 0, 0, 
     0, 0, 0};

// OLL 24
static int b_OLL_24[9] = 
    {0, 1, 1, 
     1, 1, 1, 
     0, 1, 1};

static int s_OLL_24[4][3] = 
    {1, 0, 0, 
     0, 0, 0, 
     0, 0, 1, 
     0, 0, 0};

// OLL 25
static int b_OLL_25[9] = 
    {1, 1, 0, 
     1, 1, 1, 
     0, 1, 1};

static int s_OLL_25[4][3] = 
    {0, 0, 1, 
     0, 0, 0, 
     0, 0, 0, 
     1, 0, 0};

// OLL 26
static int b_OLL_26[9] = 
    {0, 1, 0, 
     1, 1, 1, 
     0, 1, 1};

static int s_OLL_26[4][3] = 
    {0, 0, 1, 
     0, 0, 0, 
     0, 0, 1, 
     0, 0, 1};

// OLL 27
static int b_OLL_27[9] = 
    {0, 1, 0, 
     1, 1, 1, 
     1, 1, 0};

static int s_OLL_27[4][3] = 
    {1, 0, 0, 
     1, 0, 0, 
     1, 0, 0, 
     0, 0, 0};

// OLL 28
static int b_OLL_28[9] = 
    {1, 1, 1, 
     1, 1, 0, 
     1, 0, 1};

static int s_OLL_28[4][3] = 
    {0, 0, 0, 
     0, 1, 0, 
     0, 1, 0, 
     0, 0, 0};

// OLL 29
static int b_OLL_29[9] = 
    {1, 0, 1, 
     1, 1, 0, 
     0, 1, 0};

static int s_OLL_29[4][3] = 
    {0, 1, 0, 
     0, 1, 1, 
     0, 0, 0, 
     1, 0, 0};

// OLL 30
static int b_OLL_30[9] = 
    {1, 0, 1, 
     0, 1, 1, 
     0, 1, 0};

static int s_OLL_30[4][3] = 
    {0, 1, 0, 
     0, 0, 1, 
     0, 0, 0, 
     1, 1, 0};

// OLL 31
static int b_OLL_31[9] = 
    {1, 0, 0, 
     1, 1, 0, 
     1, 1, 0};

static int s_OLL_31[4][3] = 
    {0, 1, 1, 
     0, 1, 0, 
     1, 0, 0, 
     0, 0, 0};

// OLL 32
static int b_OLL_32[9] = 
    {0, 0, 1, 
     0, 1, 1, 
     0, 1, 1};

static int s_OLL_32[4][3] = 
    {1, 1, 0, 
     0, 0, 0, 
     0, 0, 1, 
     0, 1, 0};

// OLL 33
static int b_OLL_33[9] = 
    {0, 0, 1, 
     1, 1, 1, 
     0, 0, 1};

static int s_OLL_33[4][3] = 
    {1, 1, 0, 
     0, 0, 0, 
     0, 1, 1, 
     0, 0, 0};

// OLL 34
static int b_OLL_34[9] = 
    {0, 0, 0, 
     1, 1, 1, 
     1, 0, 1};

static int s_OLL_34[4][3] = 
    {0, 1, 0, 
     1, 0, 0, 
     0, 1, 0, 
     0, 0, 1};

// OLL 35
static int b_OLL_35[9] = 
    {1, 0, 0, 
     0, 1, 1, 
     0, 1, 1};

static int s_OLL_35[4][3] = 
    {0, 1, 0, 
     1, 0, 0, 
     0, 0, 1, 
     0, 1, 0};

// OLL 36
static int b_OLL_36[9] = 
    {1, 0, 0, 
     1, 1, 0, 
     0, 1, 1};

static int s_OLL_36[4][3] = 
    {0, 1, 0, 
     1, 1, 0, 
     0, 0, 1, 
     0, 0, 0};

// OLL 37
static int b_OLL_37[9] = 
    {0, 0, 1, 
     1, 1, 0, 
     1, 1, 0};

static int s_OLL_37[4][3] = 
    {1, 1, 0, 
     0, 1, 1, 
     0, 0, 0, 
     0, 0, 0};

// OLL 38
static int b_OLL_38[9] = 
    {0, 0, 1, 
     0, 1, 1, 
     1, 1, 0};

static int s_OLL_38[4][3] = 
    {0, 1, 0, 
     0, 0, 0, 
     1, 0, 0, 
     0, 1, 1};

// OLL 39
static int b_OLL_39[9] = 
    {0, 0, 1, 
     1, 1, 1, 
     1, 0, 0};

static int s_OLL_39[4][3] = 
    {1, 1, 0, 
     0, 0, 1, 
     0, 1, 0, 
     0, 0, 0};

// OLL 40
static int b_OLL_40[9] = 
    {1, 0, 0, 
     1, 1, 1, 
     0, 0, 1};

static int s_OLL_40[4][3] = 
    {0, 1, 1, 
     0, 0, 0, 
     0, 1, 0, 
     1, 0, 0};

// OLL 41
static int b_OLL_41[9] = 
    {1, 0, 1, 
     0, 1, 1, 
     0, 1, 0};

static int s_OLL_41[4][3] = 
    {0, 1, 0, 
     0, 0, 0, 
     1, 0, 1, 
     0, 1, 0};

// OLL 42
static int b_OLL_42[9] = 
    {1, 0, 1, 
     1, 1, 0, 
     0, 1, 0};

static int s_OLL_42[4][3] = 
    {0, 1, 0, 
     0, 1, 0, 
     1, 0, 1, 
     0, 0, 0};

// OLL 43
static int b_OLL_43[9] = 
    {1, 0, 0, 
     1, 1, 0, 
     1, 1, 0};

static int s_OLL_43[4][3] = 
    {0, 1, 0, 
     1, 1, 1, 
     0, 0, 0, 
     0, 0, 0};

// OLL 44
static int b_OLL_44[9] = 
    {0, 0, 1, 
     0, 1, 1, 
     0, 1, 1};

static int s_OLL_44[4][3] = 
    {0, 1, 0, 
     0, 0, 0, 
     0, 0, 0, 
     1, 1, 1};

// OLL 45
static int b_OLL_45[9] = 
    {0, 0, 1, 
     1, 1, 1, 
     0, 0, 1};

static int s_OLL_45[4][3] = 
    {0, 1, 0, 
     0, 0, 0, 
     0, 1, 0, 
     1, 0, 1};

// OLL 46
static int b_OLL_46[9] = 
    {1, 1, 0, 
     0, 1, 0, 
     1, 1, 0};

static int s_OLL_46[4][3] = 
    {0, 0, 0, 
     1, 1, 1, 
     0, 0, 0, 
     0, 1, 0};

// OLL 47
static int b_OLL_47[9] = 
    {0, 1, 0, 
     0, 1, 1, 
     0, 0, 0};

static int s_OLL_47[4][3] = 
    {1, 0, 0, 
     1, 0, 1, 
     0, 1, 1, 
     0, 1, 0};

// OLL 48
static int b_OLL_48[9] = 
    {0, 1, 0, 
     1, 1, 0, 
     0, 0, 0};

static int s_OLL_48[4][3] = 
    {0, 0, 1, 
     0, 1, 0, 
     1, 1, 0, 
     1, 0, 1};

// OLL 49
static int b_OLL_49[9] = 
    {0, 0, 0, 
     1, 1, 0, 
     0, 1, 0};

static int s_OLL_49[4][3] = 
    {1, 1, 0, 
     1, 1, 1, 
     0, 0, 1, 
     0, 0, 0};

// OLL 50
static int b_OLL_50[9] = 
    {0, 0, 0, 
     0, 1, 1, 
     0, 1, 0};

static int s_OLL_50[4][3] = 
    {0, 1, 1, 
     0, 0, 0, 
     1, 0, 0, 
     1, 1, 1};

// OLL 51
static int b_OLL_51[9] = 
    {0, 0, 0, 
     1, 1, 1, 
     0, 0, 0};

static int s_OLL_51[4][3] = 
    {1, 1, 0, 
     1, 0, 1, 
     0, 1, 1, 
     0, 0, 0};

// OLL 52
static int b_OLL_52[9] = 
    {0, 1, 0, 
     0, 1, 0, 
     0, 1, 0};

static int s_OLL_52[4][3] = 
    {1, 0, 0, 
     1, 1, 1, 
     0, 0, 1, 
     0, 1, 0};

// OLL 53
static int b_OLL_53[9] = 
    {0, 1, 0, 
     1, 1, 0, 
     0, 0, 0};

static int s_OLL_53[4][3] = 
    {0, 0, 0, 
     1, 1, 1, 
     0, 1, 0, 
     1, 0, 1};

// OLL 54
static int b_OLL_54[9] = 
    {0, 1, 0, 
     0, 1, 1, 
     0, 0, 0};

static int s_OLL_54[4][3] = 
    {0, 0, 0, 
     1, 0, 1, 
     0, 1, 0, 
     1, 1, 1};

// OLL 55
static int b_OLL_55[9] = 
    {0, 1, 0, 
     0, 1, 0, 
     0, 1, 0};

static int s_OLL_55[4][3] = 
    {0, 0, 0, 
     1, 1, 1, 
     0, 0, 0, 
     1, 1, 1};

// OLL 56
static int b_OLL_56[9] = 
    {0, 0, 0, 
     1, 1, 1, 
     0, 0, 0};

static int s_OLL_56[4][3] = 
    {0, 1, 0, 
     1, 0, 1, 
     0, 1, 0, 
     1, 0, 1};

// OLL 57
static int b_OLL_57[9] = 
    {1, 0, 1, 
     1, 1, 1, 
     1, 0, 1};

static int s_OLL_57[4][3] = 
    {0, 1, 0, 
     0, 0, 0, 
     0, 1, 0, 
     0, 0, 0};

./src/types.h:

#ifndef TYPES_H
#define TYPES_H

// Forward declarations for all major structs
// to prevent circular dependencies
typedef struct Window Window;
typedef struct Scene Scene;

#endif /* TYPES_H */ 